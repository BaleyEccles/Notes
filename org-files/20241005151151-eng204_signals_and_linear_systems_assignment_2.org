:PROPERTIES:
:ID:       7d1bb30c-084d-4895-9100-22b39a5c4f8c
:END:
#+title: ENG204 - Signals and Linear Systems - Assignment 2
#+date: [2024-10-05 Sat 15:11]
#+AUTHOR: Baley Eccles - 652137
#+FILETAGS: :Assignment:TODO:UTAS:2024:
#+STARTUP: latexpreview
#+LATEX_HEADER: \usepackage[a4paper, margin=2.5cm]{geometry}
#+LATEX_HEADER_EXTRA: \usepackage{minted}
#+LATEX_HEADER_EXTRA: \usepackage{fontspec}
#+LATEX_HEADER_EXTRA: \setmonofont{Iosevka}
#+LATEX_HEADER_EXTRA: \setminted{fontsize=\small, frame=single, breaklines=true}
#+LATEX_HEADER_EXTRA: \usemintedstyle{emacs}
#+LATEX_HEADER_EXTRA: \usepackage[backend=biber,style=apa]{biblatex}
#+LATEX_HEADER_EXTRA: \addbibresource{citation.bib}
#+LATEX_HEADER_EXTRA: \usepackage{float}

* ENG204 - Signals and Linear Systems - Assignment 2
** 1. Frequency Domain Analysis of an Audio Signal
#+BEGIN_SRC octave :exports none :results output :session Q1
clc
clear
close all
Signal = load('/home/Baley/UTAS/ENG204 - Signals And Linear Systems/Assignment 2.1/audio_signal_1.mat');
fourierCoeffs = Signal.fourierSeriesCoeffs;

% Convert to magnitude and phase
SignalMag = abs(fourierCoeffs);
SignalPhase = angle(fourierCoeffs);

SampleFreq = 44100;
N = length(fourierCoeffs);
f = (0:N-1)*(SampleFreq/N);

% Plot Magnitude vs Frequency
figure;
plot(f, SignalMag, 'b', 'LineWidth', 1.5);
title('Magnitude of Fourier Transform');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
grid on;
legend('Magnitude');
xlim([SampleFreq/2, SampleFreq]);

% Plot Phase vs Frequency
figure;
plot(f, SignalPhase, 'r', 'LineWidth', 1.5);
title('Phase of Fourier Transform');
xlabel('Frequency (Hz)');
ylabel('Phase (radians)');
grid on;
legend('Phase');
xlim([SampleFreq/2, SampleFreq]);
#+END_SRC

#+RESULTS:


#+BEGIN_SRC octave :exports code :results output :session Q1
clc;
clear;
close all;

% Load the data
Signal = load('/home/Baley/UTAS/ENG204 - Signals And Linear Systems/Assignment 2.1/audio_signal_1.mat');
Signal = Signal.fourierSeriesCoeffs;

Fs = 44100;
N = length(Signal);
f = (-N/2:N/2-1)*(Fs/N);

% Original Audio
audiowrite('audio.wav', ifft(Signal), Fs);


magnitude = abs(fftshift(Signal));
phase = angle(fftshift(Signal));

% Plot magnitude and phase spectrum
figure;
subplot(2,1,1);
plot(f, magnitude);
title('Magnitude Spectrum');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
xlim([-Fs/2 Fs/2]);

subplot(2,1,2);
plot(f, phase);
title('Phase Spectrum');
xlabel('Frequency (Hz)');
ylabel('Phase (radians)');
xlim([-Fs/2 Fs/2]);


n = 50000;
[magnitudeSorted, idx] = sort(magnitude, 'descend');
idx = idx(1:n);
output = zeros(size(Signal));
for i = 1:n
  output(idx(i)) = Signal(idx(i));
end

audiowrite('synthesized_audio.wav', ifft(output), Fs);

magnitude = abs(fftshift(output));
phase = angle(fftshift(output));

% Plot magnitude and phase spectrum
figure;
subplot(2,1,1);
plot(f, magnitude);
title('Magnitude Spectrum');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
xlim([-Fs/2 Fs/2]);

subplot(2,1,2);
plot(f, phase);
title('Phase Spectrum');
xlabel('Frequency (Hz)');
ylabel('Phase (radians)');
xlim([-Fs/2 Fs/2]);
#+END_SRC

#+RESULTS:
** 2. Ideal Filtering :TODO:

#+BEGIN_SRC octave :exports code :results output :session Filter
clc
clear
close all

f1 = 250;
f2 = 750;
Td = 2;
Fs = 3200;
N = Td*Fs;
n = 0:(N-1);
wd1 = 2*pi*f1/Fs;
wd2 = 2*pi*f2/Fs;
Phi = ((wd2-wd1)/(2*(N-1)))*n.^2+wd1*n;
Chirp = cos(Phi);
audiowrite('chirp.wav', Chirp, Fs);

magnitudeChirp = abs(fftshift(fft(Chirp)));
f = (-N/2:N/2-1)*(Fs/N);
figure;
plot(f, magnitudeChirp);
title('Magnitude Spectrum');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
grid on;

Noise = load('/home/Baley/UTAS/ENG204 - Signals And Linear Systems/Assignment 2.1/noise.mat');
Noise = Noise.noise;

audiowrite('noise.wav', Noise, 3200);

magnitudeNoise = abs(fftshift(fft(Noise)));
f = (-N/2:N/2-1)*(Fs/N);
figure;
plot(f, magnitudeNoise);
title('Magnitude Spectrum');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
grid on;

chirp_and_noise = Chirp + Noise;
audiowrite('chirp_and_noise.wav', chirp_and_noise, 3200);


magnitudeCandN = abs(fftshift(fft(chirp_and_noise)));
f = (-N/2:N/2-1)*(Fs/N);
figure;
plot(f, magnitudeCandN);
title('Magnitude Spectrum');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
grid on;
#+END_SRC

#+RESULTS:



From the frequency domain plot we can see that there is a large amount of noise at 1000Hz. On top of this there is a small mount of noise across the entire signal. So, to design our filter we will need to remove the 1000Hz component.\\
Our filter must block 1000Hz, so we can define our filter as such:
\[\begin{align*}
H(\omega)&=\begin{cases}
        1, & |\omega-2\pi1000|>\Delta\omega \\
        0, & |\omega-2\pi1000|\leq\Delta\omega
\end{cases} \\
h(t)&=\mathcal{F}^{-1}\{H(\omega)\} \\
h(t)&=\frac{1}{2\pi}\int_{0}^{2\pi 1000-\Delta\omega}1\cdot e^{j\omega t}d\omega+\frac{1}{2\pi}\int_{2\pi 1000+\Delta\omega}^{f_{end}}1\cdot e^{j\omega t}d\omega \\
h(t)&=\frac{1}{2\pi jt} \left( e^{j(2000\pi t - 2\pi \Delta\omega t)} - 1 + e^{j(f_{end}) t} - e^{j(2000\pi t + 2\pi \Delta\omega t)} \right)
\end{align*}\]
Here we use $\Delta\omega$, so we can define some tolerance for the filter.

#+BEGIN_SRC octave :exports code :results output :session Filter
close all

freq = (-N/2:N/2-1)*(Fs/N);
Df = 1;
filter = ones(size(freq));
filter((freq >= -1000 - Df & freq <= -1000 + Df) | (freq >= 1000 - Df & freq <= 1000 + Df)) = 0;

chirp_and_noise_filtered = fftshift(fft(chirp_and_noise)).*filter;

magnitudeFiltered = abs(chirp_and_noise_filtered);
f = (-N/2:N/2-1)*(Fs/N);
figure;
plot(f, magnitudeFiltered);
title('Magnitude Spectrum');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
grid on;

f = (-N/2:N/2-1)*(Fs/N);
figure;
plot(f, filter);
title('Filter');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
grid on;


audiowrite('chirp_and_noise_filtered.wav', ifft(ifftshift(chirp_and_noise_filtered)), 3200);
#+END_SRC

#+RESULTS:

However, this filter is not causal. To make it cause we need to shift the time domain signal: :TODO:
#+BEGIN_SRC octave :exports code :results output :session Filter
close all
freq = (-N/2:N/2-1)*(Fs/N);
Df = 3;
filter = ones(size(freq));
filter((freq >= -1000 - Df & freq <= -1000 + Df) | (freq >= 1000 - Df & freq <= 1000 + Df)) = 0;
filterTimeDomain = ifft(fftshift(filter));
plot(1:length(filterTimeDomain), filterTimeDomain)

#+END_SRC

#+RESULTS:

** Aliasing and Anti-Aliasing Filters




#+BEGIN_SRC octave :exports code :results output :session Aliasing
clc
clear
close all
pkg load control
pkg load signal
[wav, Fs] = audioread('/home/Baley/UTAS/ENG204 - Signals And Linear Systems/Assignment 2.1/audio_signal_2.wav');

t = (0:length(wav)-1) / Fs;
figure;
plot(t, wav);
title('Time Domain Signal');
xlabel('Time (seconds)');
ylabel('Amplitude');
grid on;

figure;
N = length(wav);
magnitude = abs(fftshift(fft(wav)));
f = (0:N-1)*(Fs/N);
plot(f, magnitude);
title('Fourier Magnitude');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
grid on;


Fs_original = Fs;
t_original = (0:length(wav)-1) / Fs_original;

Fs_new = [88.2*10^3, 11.025*10^3, 5.5*10^3, 2.8*10^3];
num_new_freqs = length(Fs_new);

wav_all = cell(num_new_freqs, 1);

figure;
for i = 1:num_new_freqs
    t_new = (0:1/Fs_new(i):(length(wav)-1)/Fs_original);

    wav_new = interp1(t_original, wav, t_new, 'linear');

    subplot(num_new_freqs, 1, i);
    plot(t_new, wav_new);
    title(['Signal Sampled at ', num2str(Fs_new(i)/1*10^3), ' kHz']);

    xlabel('Time (seconds)');
    ylabel('Amplitude');
    grid on;
    audiowrite(['Signal Sampled at ', num2str(Fs_new(i)/1*10^3), ' kHz.wav'], wav_new, Fs_new(i));

    wav_all{i} = wav_new;
end


function [Bpoles] = butterWorth(wc, N) % gives the poles for a Butterworth filter
  Bpoles = wc * exp (j * pi * (2 * [1:N] + N - 1) / (2 * N));
  if (mod (N, 2) == 1)
    Bpoles((N + 1) / 2) = -wc;
  endif
endfunction

function [Cpoles] = chebyshev(w1, e, N) % gives the poles for a Chebyshev filter
  Cpoles = zeros(1, N);
  for k = 1:N
    ak = ((2*k-1)*pi)/(2*N);
    bk = asinh(1/e);
    s = 1j * w1 * (cos(ak) * cosh(bk) - 1j * sin(ak) * sinh(bk));
    Cpoles(k) = s;
  end
  Cpoles = -1*Cpoles; % Return the left side poles
endfunction

f = 10000;
wc = 2*pi*f;
N = 5;
[Bpole] = butterWorth(wc, N);
ButterTF = tf(poly([]), real(poly(Bpole)));

figure;
flogButter = logspace(-2, 4, 100);
freqs(poly([]), real(poly(Bpole)), 2*pi*flogButter);
xlabel('Frequency (Hz)');

w1 = 2*pi*f;
e = 10;
[Cpole] = chebyshev(w1, e, N);
ChebyTF = tf(poly([]), real(poly(Cpole)));

figure;
flogCheby = logspace(-2, 4, 100);
freqs(poly([]), real(poly(Cpole)), 2*pi*flogCheby);
xlabel('Frequency (Hz)');



#+END_SRC

#+RESULTS:

** Impact of Noise on Analogue and Digital Systems
*** Autocorrelation and Wide-Sense Stationary Signals

#+BEGIN_SRC octave :exports code :results output :session Autocorrelation
clc
clear
close all
pkg load signal

num_samples = 1000;
signal_length = 200;
w1 = 2 * pi * 0.01;
w2 = 2 * pi * 0.02;


for i = 1:num_samples
  phi1 = rand() * 2 * pi;
  phi2 = rand() * 2 * pi;
  A = rand() * 4 - 2;

  t = 0:signal_length-1;
  X1(i, :) = cos(w1 * t + phi1) - sin(w2 * t + phi2);
  X2(i, :) = A * (cos(w1 * t) + sin(w2 * t));
end

ensemble_mean_X1 = mean(X1, 1);
ensemble_mean_X2 = mean(X2, 1);

time_mean_X1 = mean(X1, 2);
time_mean_X2 = mean(X2, 2);

[auto_corr_X1, lags_X1] = xcorr(X1(:, 1)); % THE AUTO CORR SEEMS WRONG :TODO:
[auto_corr_X2, lags_X2] = xcorr(X2(:, 1));

time = 0:(signal_length-1);
figure;
subplot(2, 1, 1);
plot(time, ensemble_mean_X1);
title('Ensemble Mean of X_1(t)');
xlabel('Time');
ylabel('Ensemble Mean of X_1(t)');

subplot(2, 1, 2);
plot(time, ensemble_mean_X2);
title('Ensemble Mean of X_2(t)');
xlabel('Time');
ylabel('Ensemble Mean of X_2(t)');

time = 0:(num_samples-1);
figure;
subplot(2, 1, 1);
plot(time, time_mean_X1);
title('Time Mean of X_1(t)');
xlabel('Time');
ylabel('Time Mean of X_1(t)');

subplot(2, 1, 2);
plot(time, time_mean_X2);
title('Time Mean of X_2(t)');
xlabel('Time');
ylabel('Time Mean of X_2(t)');

figure;
subplot(2, 1, 1);
plot(lags_X1, auto_corr_X1);
title('Autocorrelation of X_1(t)');
xlabel('Lag');
ylabel('Autocorrelation of X_1(t)');

subplot(2, 1, 2);
plot(lags_X2, auto_corr_X2);
title('Autocorrelation of X_2(t)');
xlabel('Lag');
ylabel('Autocorrelation of X_2(t)');

#+END_SRC

#+RESULTS:

**** Ensemble Mean
The ensemble mean of $X_1(t)$ can be calculated as follows:
\[\begin{align*}
E[X_1(t)] &= E[\cos(\omega_1t+\Phi_1) - \sin(\omega_2t+\Phi_2)] \\
          &= \int_0^{2\pi}\cos(\omega_1t+\Phi_1)\frac{1}{2\pi}d\phi_1- \int_0^{2\pi}\sin(\omega_2t+\Phi_2)\frac{1}{2\pi}d\phi_2 \\
          &= 0
\end{align*}\]
The ensemble mean of $X_2(t)$ can be calculated as follows:
\[\begin{align*}
E[X_2(t)] &= E[A]\cdot E[\cos(\omega_1t)]+E[A]\cdot E[\sin(\omega_2t)] \\
\textrm{where: } E[A]  &= \int_{-2}^{2}a\frac{1}{4}da = 0 \\
\Rightarrow E[X_2(t)] &= 0\cdot E[\cos(\omega_1t)]+0\cdot E[\sin(\omega_2t)] = 0
\end{align*}\]
**** Time Mean
The time mean of $X_1(t)$ can be calculated as follows:
\[\begin{align*}
\overline{X_1(t)} &= \lim_{T\rightarrow\infty}\frac{1}{T}\int_{\frac{T}{2}}^{\frac{T}{2}}\cos(\omega_1t+\Phi_1) - \sin(\omega_2t+\Phi_2)dt \\
         &= 0
\end{align*}\]
The time mean of $X_2(t)$ can be calculated as follows:
\[\begin{align*}
\overline{X_2(t)} &= \lim_{T\rightarrow\infty}\frac{1}{T}\int_{\frac{T}{2}}^{\frac{T}{2}}A(\cos(\omega_1t)+\sin(\omega_2t)) dt \\
         &= 0
\end{align*}\]
Both of which are not functions of time, satisfying the first prong of being wide-sense stationary.
**** Autocorrelation
The autocorrelation of $X_1(t)$ can be calculated as follows:
\[\begin{align*}
R_{X_1}(t,t+\tau) &= E[X_1(t)X_1(t+\tau)] \\
&= E[\cos(\omega_1​t+\Phi_1​)-\sin(\omega_2​t+\Phi_2​))(\cos(\omega_1​(t+\tau)+\Phi_1​)-\sin(\omega_2​(t+\tau)+\Phi_2​)] \\
&\textrm{After some arithmatic and trigonometric identies:} \\
R_{X_1}(t,t+\tau) &= \frac{1}{2}\cos(\omega_1\tau)+\frac{1}{2}\cos(\omega_2\tau)
\end{align*}\]
The autocorrelation of $X_1(t)$ can be calculated as follows:
\[\begin{align*}
R_{X_2}(t,t+\tau) &= E[X_2(t)X_2(t+\tau)] \\
&= E[A^2(\cos(\omega_1t)+\sin(\omega_2t))(\omega_1(t+\tau))+\sin(\omega_2(t+\tau))] \\
&\textrm{Which becomes:} \\
R_{X_2}(t,t+\tau) &= \frac{4}{3}(\cos(\omega_1\tau)+\sin(\omega_2\tau))
\end{align*}\]
Both of which are only functions of $\tau$, satisfying the second prong of wide-sense stationary. So, both of the functions are wide-sense stationary.
**** Different Stochastic Processes
#+BEGIN_SRC octave :exports code :results output :session Diff
clc
clear
close all
pkg load signal

num_samples = 1000;
signal_length = 200;
w1 = 2 * pi * 0.01;
w2 = 2 * pi * 0.02;


for i = 1:num_samples
  phi1 = rand() * 2 * pi;
  phi2 = rand() * 2 * pi;
  A = rand() * 4 - 2;

  t = 0:signal_length-1;
  X1(i, :) = cos(w1 * t + phi1) - sin(w2 * t + phi2);
  X2(i, :) = A * (cos(w1 * t) + sin(w2 * t));
end

ensemble_mean_X1 = mean(X1, 1);
ensemble_mean_X2 = mean(X2, 1);

time_mean_X1 = mean(X1, 2);
time_mean_X2 = mean(X2, 2);

[auto_corr_X1, lags_X1] = xcorr(X1(:, 1)); % THE AUTO CORR SEEMS WRONG :TODO:
[auto_corr_X2, lags_X2] = xcorr(X2(:, 1));

time = 0:(signal_length-1);
figure;
subplot(2, 1, 1);
plot(time, ensemble_mean_X1);
title('Ensemble Mean of X_1(t)');
xlabel('Time');
ylabel('Ensemble Mean of X_1(t)');

subplot(2, 1, 2);
plot(time, ensemble_mean_X2);
title('Ensemble Mean of X_2(t)');
xlabel('Time');
ylabel('Ensemble Mean of X_2(t)');

time = 0:(num_samples-1);
figure;
subplot(2, 1, 1);
plot(time, time_mean_X1);
title('Time Mean of X_1(t)');
xlabel('Time');
ylabel('Time Mean of X_1(t)');

subplot(2, 1, 2);
plot(time, time_mean_X2);
title('Time Mean of X_2(t)');
xlabel('Time');
ylabel('Time Mean of X_2(t)');

figure;
subplot(2, 1, 1);
plot(lags_X1, auto_corr_X1);
title('Autocorrelation of X_1(t)');
xlabel('Lag');
ylabel('Autocorrelation of X_1(t)');

subplot(2, 1, 2);
plot(lags_X2, auto_corr_X2);
title('Autocorrelation of X_2(t)');
xlabel('Lag');
ylabel('Autocorrelation of X_2(t)');


#+END_SRC

#+RESULTS:

*** Power spectral density :TODO:

The transfer function of the LCL filter is given by:

#+BEGIN_SRC octave :exports code :results output :session PSD
clc
clear
close all

H = tf(poly([]), [L])
#+END_SRC
