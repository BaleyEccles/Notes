:PROPERTIES:
:ID:       7d1bb30c-084d-4895-9100-22b39a5c4f8c
:END:
#+title: ENG204 - Signals and Linear Systems - Assignment 2
#+date: [2024-10-05 Sat 15:11]
#+AUTHOR: Baley Eccles - 652137
#+FILETAGS: :Assignment:TODO:
#+STARTUP: latexpreview
#+LATEX_HEADER: \usepackage[a4paper, margin=2.5cm]{geometry}
#+LATEX_HEADER_EXTRA: \usepackage{minted}
#+LATEX_HEADER_EXTRA: \usepackage{fontspec}
#+LATEX_HEADER_EXTRA: \setmonofont{Iosevka}
#+LATEX_HEADER_EXTRA: \setminted{fontsize=\small, frame=single, breaklines=true}
#+LATEX_HEADER_EXTRA: \usemintedstyle{emacs}
#+LATEX_HEADER_EXTRA: \usepackage[backend=biber,style=apa]{biblatex}
#+LATEX_HEADER_EXTRA: \addbibresource{citation.bib}
#+LATEX_HEADER_EXTRA: \usepackage{float}

* ENG204 - Signals and Linear Systems - Assignment 2
** 1. Frequency Domain Analysis of an Audio Signal
#+BEGIN_SRC octave :exports none :results output :session Q1
clc
clear
close all
Signal = load('/home/Baley/UTAS/ENG204 - Signals And Linear Systems/Assignment 2.1/audio_signal_1.mat');
fourierCoeffs = Signal.fourierSeriesCoeffs;

% Convert to magnitude and phase
SignalMag = abs(fourierCoeffs);
SignalPhase = angle(fourierCoeffs);

SampleFreq = 44100;
N = length(fourierCoeffs);
f = (0:N-1)*(SampleFreq/N);

% Plot Magnitude vs Frequency
figure;
plot(f, SignalMag, 'b', 'LineWidth', 1.5);
title('Magnitude of Fourier Transform');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
grid on;
legend('Magnitude');
xlim([SampleFreq/2, SampleFreq]);

% Plot Phase vs Frequency
figure;
plot(f, SignalPhase, 'r', 'LineWidth', 1.5);
title('Phase of Fourier Transform');
xlabel('Frequency (Hz)');
ylabel('Phase (radians)');
grid on;
legend('Phase');
xlim([SampleFreq/2, SampleFreq]);
#+END_SRC

#+RESULTS:


#+BEGIN_SRC octave :exports code :results output :session Q1
clc;
clear;
close all;

% Load the data
Signal = load('/home/Baley/UTAS/ENG204 - Signals And Linear Systems/Assignment 2.1/audio_signal_1.mat');
Signal = Signal.fourierSeriesCoeffs;

Fs = 44100;
N = length(Signal);
f = (-N/2:N/2-1)*(Fs/N);

% Original Audio
audiowrite('audio.wav', ifft(Signal), Fs);


magnitude = abs(fftshift(Signal));
phase = angle(fftshift(Signal));

% Plot magnitude and phase spectrum
figure;
subplot(2,1,1);
plot(f, magnitude);
title('Magnitude Spectrum');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
xlim([-Fs/2 Fs/2]);

subplot(2,1,2);
plot(f, phase);
title('Phase Spectrum');
xlabel('Frequency (Hz)');
ylabel('Phase (radians)');
xlim([-Fs/2 Fs/2]);


n = 50000;
[magnitudeSorted, idx] = sort(magnitude, 'descend');
idx = idx(1:n);
output = zeros(size(Signal));
for i = 1:n
  output(idx(i)) = Signal(idx(i));
end

audiowrite('synthesized_audio.wav', ifft(output), Fs);

magnitude = abs(fftshift(output));
phase = angle(fftshift(output));

% Plot magnitude and phase spectrum
figure;
subplot(2,1,1);
plot(f, magnitude);
title('Magnitude Spectrum');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
xlim([-Fs/2 Fs/2]);

subplot(2,1,2);
plot(f, phase);
title('Phase Spectrum');
xlabel('Frequency (Hz)');
ylabel('Phase (radians)');
xlim([-Fs/2 Fs/2]);
#+END_SRC

#+RESULTS:
** 2. Ideal Filtering :TODO:

#+BEGIN_SRC octave :exports code :results output :session Filter
clc
clear
close all

f1 = 250;
f2 = 750;
Td = 2;
Fs = 3200;
N = Td*Fs;
n = 0:(N-1);
wd1 = 2*pi*f1/Fs;
wd2 = 2*pi*f2/Fs;
Phi = ((wd2-wd1)/(2*(N-1)))*n.^2+wd1*n;
Chirp = cos(Phi);
audiowrite('chirp.wav', Chirp, Fs);

magnitudeChirp = abs(fftshift(fft(Chirp)));
f = (-N/2:N/2-1)*(Fs/N);
figure;
plot(f, magnitudeChirp);
title('Magnitude Spectrum');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
grid on;

Noise = load('/home/Baley/UTAS/ENG204 - Signals And Linear Systems/Assignment 2.1/noise.mat');
Noise = Noise.noise;

audiowrite('noise.wav', Noise, 3200);

magnitudeNoise = abs(fftshift(fft(Noise)));
f = (-N/2:N/2-1)*(Fs/N);
figure;
plot(f, magnitudeNoise);
title('Magnitude Spectrum');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
grid on;

chirp_and_noise = Chirp + Noise;
audiowrite('chirp_and_noise.wav', chirp_and_noise, 3200);


magnitudeCandN = abs(fftshift(fft(chirp_and_noise)));
f = (-N/2:N/2-1)*(Fs/N);
figure;
plot(f, magnitudeCandN);
title('Magnitude Spectrum');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
grid on;
#+END_SRC

#+RESULTS:



From the frequency domain plot we can see that there is a large amount of noise at 1000Hz. On top of this there is a small mount of noise across the entire signal. So, to design our filter we will need to remove the 1000Hz component.\\
Our filter must block 1000Hz, so we can define our filter as such:
\[\begin{align*}
H(\omega)&=\begin{cases}
        1, & |\omega-2\pi1000|>\Delta\omega \\
        0, & |\omega-2\pi1000|\leq\Delta\omega
\end{cases} \\
h(t)&=\mathcal{F}^{-1}\{H(\omega)\} \\
h(t)&=\frac{1}{2\pi}\int_{0}^{2\pi 1000-\Delta\omega}1\cdot e^{j\omega t}d\omega+\frac{1}{2\pi}\int_{2\pi 1000+\Delta\omega}^{f_{end}}1\cdot e^{j\omega t}d\omega \\
h(t)&=\frac{1}{2\pi jt} \left( e^{j(2000\pi t - 2\pi \Delta\omega t)} - 1 + e^{j(f_{end}) t} - e^{j(2000\pi t + 2\pi \Delta\omega t)} \right)
\end{align*}\]
Here we use $\Delta\omega$, so we can define some tolerance for the filter.

#+BEGIN_SRC octave :exports code :results output :session Filter
close all

freq = (-N/2:N/2-1)*(Fs/N);
Df = 1;
filter = ones(size(freq));
filter((freq >= -1000 - Df & freq <= -1000 + Df) | (freq >= 1000 - Df & freq <= 1000 + Df)) = 0;

chirp_and_noise_filtered = fftshift(fft(chirp_and_noise)).*filter;

magnitudeFiltered = abs(chirp_and_noise_filtered);
f = (-N/2:N/2-1)*(Fs/N);
figure;
plot(f, magnitudeFiltered);
title('Magnitude Spectrum');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
grid on;

f = (-N/2:N/2-1)*(Fs/N);
figure;
plot(f, filter);
title('Filter');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
grid on;


audiowrite('chirp_and_noise_filtered.wav', ifft(ifftshift(chirp_and_noise_filtered)), 3200);
#+END_SRC

#+RESULTS:

However, this filter is not causal. To make it cause we need to shift the time domain signal: :TODO:
#+BEGIN_SRC octave :exports code :results output :session Filter
close all
freq = (-N/2:N/2-1)*(Fs/N);
Df = 3;
filter = ones(size(freq));
filter((freq >= -1000 - Df & freq <= -1000 + Df) | (freq >= 1000 - Df & freq <= 1000 + Df)) = 0;
filterTimeDomain = ifft(fftshift(filter));
plot(1:length(filterTimeDomain), filterTimeDomain)

#+END_SRC

#+RESULTS:

** Aliasing and Anti-Aliasing Filters


#+BEGIN_SRC octave :exports code :results output :session Aliasing
clc
clear
close all
pkg load control
pkg load signal
[wav, Fs] = audioread('/home/Baley/UTAS/ENG204 - Signals And Linear Systems/Assignment 2.1/audio_signal_2.wav');

t = (0:length(wav)-1) / Fs;
figure;
plot(t, wav);
title('Time Domain Signal');
xlabel('Time (seconds)');
ylabel('Amplitude');
grid on;

figure;
N = length(wav);
magnitude = abs(fftshift(fft(wav)));
f = (0:N-1)*(Fs/N);
plot(f, magnitude);
title('Fourier Magnitude');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
grid on;


Fs_original = Fs;
t_original = (0:length(wav)-1) / Fs_original;

Fs_new = [88.2*10^3, 11.025*10^3, 5.5*10^3, 2.8*10^3];
num_new_freqs = length(Fs_new);

wav_all = cell(num_new_freqs, 1);

figure;
for i = 1:num_new_freqs
    t_new = (0:1/Fs_new(i):(length(wav)-1)/Fs_original);

    wav_new = interp1(t_original, wav, t_new, 'linear');

    subplot(num_new_freqs, 1, i);
    plot(t_new, wav_new);
    title(['Signal Sampled at ', num2str(Fs_new(i)/1*10^3), ' kHz']);

    xlabel('Time (seconds)');
    ylabel('Amplitude');
    grid on;
    audiowrite(['Signal Sampled at ', num2str(Fs_new(i)/1*10^3), ' kHz.wav'], wav_new, Fs_new(i));

    wav_all{i} = wav_new;
end


function [Bpoles] = butterWorth(wc, N) % gives the poles for a Butterworth filter
  Bpoles = wc * exp (j * pi * (2 * [1:N] + N - 1) / (2 * N));
  if (mod (N, 2) == 1)
    Bpoles((N + 1) / 2) = -wc;
  endif
endfunction

function [Cpoles] = chebyshev(w1, e, N) % gives the poles for a Chebyshev filter
  Cpoles = zeros(1, N);
  for k = 1:N
    ak = ((2*k-1)*pi)/(2*N);
    bk = asinh(1/e);
    s = 1j * w1 * (cos(ak) * cosh(bk) - 1j * sin(ak) * sinh(bk));
    Cpoles(k) = s;
  end
  Cpoles = -1*Cpoles; % Return the left side poles
endfunction

f = 10000;
wc = 2*pi*f;
N = 5;
[Bpole] = butterWorth(wc, N);
ButterTF = tf(poly([]), real(poly(Bpole)));

figure;
flogButter = logspace(-2, 4, 100);
freqs(poly([]), real(poly(Bpole)), 2*pi*flogButter);
xlabel('Frequency (Hz)');

w1 = 2*pi*f;
e = 10;
[Cpole] = chebyshev(w1, e, N);
ChebyTF = tf(poly([]), real(poly(Cpole)));

figure;
flogCheby = logspace(-2, 4, 100);
freqs(poly([]), real(poly(Cpole)), 2*pi*flogCheby);
xlabel('Frequency (Hz)');



#+END_SRC

#+RESULTS:
