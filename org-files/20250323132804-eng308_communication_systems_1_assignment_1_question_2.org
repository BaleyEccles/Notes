:PROPERTIES:
:ID:       358ec344-ce1e-4d60-be9f-b0b6529d4649
:END:
#+title: ENG308 - Communication Systems 1 - Assignment 1 - Question 2
#+date: [2025-03-23 Sun 13:28]
#+AUTHOR: Baley Eccles - 652137
#+FILETAGS: :Assignment:UTAS:2025:
#+STARTUP: latexpreview

* Part a
If we integrate the message signal and then do phase modulation on it we will get the frequency modulated signal. Likewise, if we differentiate the message and then do frequency modulation on it we will get the phase modulated signal
Where:
\[u_{PM}(t) = A_c\cos(2\pi f_ct + k_pm(t))\]
\[u_{FM}(t) = A_c\cos(2\pi f_ct + 2\pi k_f\int_{-\infty}^tm(\tau)d\tau)\]
taking $k_p = 2\cdotpi\cdot0.0001$ and $k_f = 0.0001$. $k_p$ must be a factor of $2\pi$ larger than $k_f$ to produce the desired results, as in the FM equation there is an extra $2\pi$ on $k_f$.
#+BEGIN_SRC octave :exports none :results output :session ALL :eval no-export
%% Part A
clear all;
close all;

%% Make compatible with MATLAB and Octave
if exist('OCTAVE_VERSION', 'builtin')
  pkg load signal
  set(0, "DefaultAxesFontSize", 25);
end

%% Parameters
fc = 1000;                    % carrier frequency (Hz)
Fs = 1000 * fc;               % sampling frequency
t = 0 : 1/Fs : 0.075;          % time vector
N = length(t);                % number of samples
f = (-N/2 : N/2-1) * (Fs/N);  % frequency vector
w = 2 * pi;

%% Modulating signal parameters
Ac = 1;
kp = 2*pi*0.0001;
kf = 0.0001;
A1 = 1;
A2 = 20;
A3 = 10;
f1 = 50;
f2 = 100;
f3 = 150;
phi1 = pi/2;
phi2 = pi;
phi3 = pi/3;

m = A1 * cos(w * f1 * t + phi1) + A2 * cos(w * f2 * t + phi2) + A3 * cos(w * f3 * t + phi3);
#+END_SRC

#+RESULTS:

#+BEGIN_SRC octave :exports none :results output :session ALL :eval no-export
im = cumtrapz(m);
iu_PM = Ac*cos(2*pi*fc*t + kp*im);
u_FM = Ac*cos(2*pi*fc*t + 2*pi*kf*cumtrapz(m));

dm = diff(m);
du_FM = Ac*cos(2*pi*fc*t(2:end) + 2*pi*kf*cumtrapz(dm(1:end)));
u_PM = Ac*cos(2*pi*fc*t + kp*m);


figure;
subplot(2,1,1);
plot(t(1:end), iu_PM, 'linewidth', 2)
title('Integral of message signal then phase modulated');
xlabel('Time (s)');
ylabel('Amplitude');
xlim([0, 0.0075]);
subplot(2,1,2);
plot(t(1:end), u_FM, 'linewidth', 2)
title('Frequency modulation of the message signal');
xlabel('Time (s)');
ylabel('Amplitude');
xlim([0, 0.0075]);
print -dpng 'Integral_then_phase_modulated.png'

%% Plot 2
figure;
subplot(2,1,1);
plot(t(2:end), du_FM, 'linewidth', 2)
title('Derivative of message signal then frequency modulated');
xlabel('Time (s)');
ylabel('Amplitude');
xlim([0, 0.075]);
subplot(2,1,2);
plot(t(2:end), u_PM(2:end), 'linewidth', 2)
title('Phase modulation of the message signal');
xlabel('Time (s)');
ylabel('Amplitude');
xlim([0, 0.075]);
print -dpng 'Derivative_then_frequency_modulated.png'
#+END_SRC

#+RESULTS:

The modulation index can be calculated using:
\[\beta_f = \frac{k_f A_m}{\max(f_m)}\]
For FM, and
\[\beta_p = k_pA_m\]
For PM.
#+BEGIN_SRC octave :exports none :results output :session ALL :eval no-export
Am = max(abs(m));

bf = kf*Am/max([f1, f2, f3]);
bp = kp*Am;
fprintf("The modulation index for FM is %.6f\n", bf);
fprintf("The modulation index for PM is %.6f\n", bp);
#+END_SRC

#+RESULTS:
: The modulation index for FM is 0.000019
: The modulation index for PM is 0.017820


* Part b
Need to show:
1. There is some small constant phase error in steady-state
2. Changing $K_f$, $A_c$, $K_o$ and $K_{PD}$ can break the locking via the equation
   - \[|\omega_c-\omega_f| \leq \frac{\pi}{2} K_fA_cK_oK_{PD}\]
3. Transient analysis

Using $f_c = 200Hz$ and $f_f = 200Hz$.
It was chosen that $K_{PD} = 1$, $K_f = 1$ and $K_{vco} = 2\pi\cdot100$.

** 1
using:
\[A_c = 1\]
\[K_f = 1\]
\[K_{PD} = 1\]
\[K_{vco} = 2\pi\cdot100\]

#+BEGIN_SRC octave :exports none :results output :session PLL1 :eval no-export
clear all;
close all;
pkg load io

data = xlsread("PLL_Data_5.xlsx");

t = data(:,1);
sin = data(:,4);
vco = data(:,5);

hold on;
plot(t, vco, 'b', 'LineWidth', 1.5);
plot(t, sin, 'r', 'LineWidth', 1.5);

xlabel('time');
ylabel('voltage');
title('constant phase difference in steady state');
legend('input', 'vco');
hold off;
print -dpng 'PLL_Const_Phase.png'
#+END_SRC

#+RESULTS:

** 2
using:
\[A_c = 1\]
\[K_f = 0.001\]
\[K_{PD} = 1\]
\[K_PD = 2\pi\cdot100\]
Which means the frequency difference must be:
\begin{align*}
\lvert\omega_c-\omega_f\rvert &\leq \frac{\pi}{2} K_fA_cK_oK_{PD} \\
\lvert\omega_c-\omega_f\rvert &\leq \frac{\pi}{2} 1\cdot0.001\cdot1\cdot2\pi\cdot100 \\
\lvert\omega_c-\omega_f\rvert &\leq 1\ rad/s
\end{align*}
So, if we set a frequency difference of greater than 1 rad/s we will expect the PLL to fail. \\

Setting $f_c = 205Hz$, $5Hz$ larger than $f_f$ we can see that PLL never locks on to the signal.

#+BEGIN_SRC octave :exports none :results output :session PLL2 :eval no-export
clear all;
close all;
pkg load io

data = xlsread("PLL_Data_6.xlsx");

t = data(:,1);
sin = data(:,4);
vco = data(:,5);

hold on;
plot(t, vco, 'b', 'LineWidth', 1.5);
plot(t, sin, 'r', 'LineWidth', 1.5);

xlabel('time');
ylabel('voltage');
title('Breaking PLL Locking');
legend('input', 'vco');
ylim([0.95, 1.05]);
hold off;
print -dpng 'PLL_No_Lock_On.png'
#+END_SRC

#+RESULTS:

** 3
Setting the values back to the ones before:
\[A_c = 1\]
\[K_f = 1\]
\[K_{PD} = 1\]
\[K_{vco} = 2\pi\cdot100\]
Introduce a frequency shift, from $f_c = 200Hz$ to $f_{c} = 150Hz$, at $t = 0.1$. From the notes: "If a frequency error occurs, the phase is tracked with a constant offset", which can be seen. That is, there is a constant phase offset after changing the frequency.

#+BEGIN_SRC octave :exports none :results output :session PLL3 :eval no-export
clear all;
close all;
pkg load io

data = xlsread("PLL_Data_7.xlsx");

t = data(:,1);
sin = data(:,7);
vco = data(:,8);

hold on;
plot(t, vco, 'b', 'LineWidth', 1.5);
plot(t, sin, 'r', 'LineWidth', 1.5);

xlabel('time');
ylabel('voltage');
title('Change in frequency');
legend('input', 'vco');
xlim([0.095, 0.13]);
hold off;
print -dpng 'PLL_Freq_Diff.png'
#+END_SRC

#+RESULTS:


* Part c
At the moment the small angle approximation is not a good approximation. The phase error is so large ($e(t) \approx 0.5$), that it is not reasonable to assume that $\sin(x) \approx x$. If we change $K_PD$ from $1$ to $0.1$ the approximation becomes much more reasonable. \\

With $K_{PD} = 0.1$ we can apply a phase step to the input of $55^o$ and see the phase error. The phase step was applied at $t = 0.1$, it can be seen that the phase error never goes above $0.1$, which means the approximation is valid

#+BEGIN_SRC octave :exports none :results output :session PLL4 :eval no-export
clear all;
close all;
pkg load io

data = xlsread("PLL_Data_9.xlsx");

t = data(:,1);
phase = data(:,2);

hold on;
plot(t, phase, 'r', 'LineWidth', 1.5);

xlabel('time');
ylabel('voltage');
title('Change in phase');
xlim([0.095, 0.13]);
hold off;
print -dpng 'PLL_Phase_Diff.png'
#+END_SRC

#+RESULTS:

Even if we apply a frequency step from $200Hz$ to $1kHz$ the approximation still holds. Even though the PLL fails to lock on it is still valid to assume that $\sin(x)\approx x$.
#+BEGIN_SRC octave :exports none :results output :session PLL4 :eval no-export
clear all;
close all;
pkg load io

data = xlsread("PLL_Data_10.xlsx");

t = data(:,1);
phase = data(:,2);

hold on;
plot(t, phase, 'r', 'LineWidth', 1.5);

xlabel('time');
ylabel('voltage');
title('Change in phase');
xlim([0.095, 0.13]);
hold off;
print -dpng 'PLL_Large_Freq_Diff.png'
#+END_SRC

#+RESULTS:
