:PROPERTIES:
:ID:       30e0f262-edfa-442f-8e1c-7abf03e3ed19
:END:
#+title: ENG331 - Control Systems 1 - Design Task
#+date: [2025-09-23 Tue 12:05]
#+AUTHOR: Baley Eccles - 652137
#+STARTUP: latexpreview

* ENG331 - Control Systems 1 - Design Task
|--------------------------------+------------------------------+--------------------------------+------------------------------|
| Actual Tank 1 Height $h_{1,i}$ | Uncalibrated value $v_{1,i}$ | Actual tank 2 height $h_{2,i}$ | Uncalibrated value $v_{2,i}$ |
|--------------------------------+------------------------------+--------------------------------+------------------------------|
|                             13 |                          255 |                           26.5 |                          548 |
|--------------------------------+------------------------------+--------------------------------+------------------------------|
|                            7.5 |                          135 |                           15.5 |                          306 |
|--------------------------------+------------------------------+--------------------------------+------------------------------|
#+BEGIN_SRC octave :exports code :results output :session Q1
clc
clear
close all

pkg load symbolic

syms s1 o1 s2 o2
h_1_1 = 13;
v_1_1 = 255;
h_2_1 = 26.5;
v_2_1 = 548;

h_1_2 = 7.5;
v_1_2 = 135;
h_2_2 = 15.5;
v_2_2 = 306;

equ1 = h_1_1 == v_1_1*s1 + o1;
equ2 = h_1_2 == v_1_2*s1 + o1;
[o1, s1] = solve(equ1, equ2)
offset1 = double(o1)
scale1 = double(s1)

equ3 = h_2_1 == v_2_1*s2 + o2;
equ4 = h_2_2 == v_2_2*s2 + o2;
[o2, s2] = solve(equ3, equ4);
offset2 = double(o2)
scale2 = double(s2)
#+END_SRC

#+RESULTS:
#+begin_example
Symbolic pkg v3.2.2: Python communication link active, SymPy v1.14.0.
warning: passing floating-point values to sym is dangerous, see "help sym"
warning: called from
    double_to_sym_heuristic at line 50 column 7
    sym at line 384 column 13
    eq at line 93 column 5
o1 = (sym)

  21
  ──
  16

s1 = (sym)

  11 
  ───
  240
offset1 = 1.3125
scale1 = 0.045833
warning: passing floating-point values to sym is dangerous, see "help sym"
warning: called from
    double_to_sym_heuristic at line 50 column 7
    sym at line 384 column 13
    eq at line 93 column 5
warning: passing floating-point values to sym is dangerous, see "help sym"
warning: called from
    double_to_sym_heuristic at line 50 column 7
    sym at line 384 column 13
    eq at line 93 column 5
offset2 = 1.5909
scale2 = 0.045455
#+end_example

* Feed Forward
** Real Tanks
|  V |  h_1 |  h_2 |
|  5 |  5.5 | 0.11 |
|  7 |    9 | 0.18 |
| 10 | 14.5 | 0.28 |

|  V |  h_2 |
|  5 | 0.11 |
|  7 | 0.18 |
| 10 | 0.28 |

At 7 volts we get zero steady state error with a feed forward term of 0.3888, which gives a tank 2 height of 18cm.

From the data above the following piece wise function can be obtained which provides the system with the required voltage for a input height.
\begin{cases}
V = 45.45h           & 0 < h < 0.11 \\
V = 28.57h + 1.86  & 0.11 < h < 0.18 \\
V = 30h + 1.6 & 0.18 < h < \infty
\end{cases}
This was tested on the real tanks and in simulation, the simulation has a larger error than in real life

** Data From Simulation
| V |   h_2 |
| 5 | 0.063 |
| 7 | 0.124 |
| 9 |   0.2 |

\begin{cases}
V = 79.37h           & 0 < x < 0.063 \\
V = 32.79h + 2.937   & 0.063 < x < 0.124 \\
V = 26.32h + 3.73832 & 0.124 < x < 0.2
\end{cases}


** Non-Linear
We want an equation that is $V_p(t) = f(h_2)$
\begin{align*}
K_{pump}V_p(t) &= \frac{\pi}{4} D_2^2 \frac{dh_2(t)}{dt} + \frac{\pi}{4}D_{o2}^2C_d\sqrt{2gh_2(t)} \\
\textrm{With } \frac{dh_2(t)}{dt} &= 0 \\
K_{pump} V_p &= \frac{\pi C_{d} D_{o2} \sqrt{2g h_{2}}}{4} \\
\Rightarrow V_p(t) &= \frac{\pi C_{d} D_{o2} \sqrt{2g h_{2}}}{4 K_{pump}} \\
\Rightarrow V_p(t) &= 19.8793\sqrt{h_2(t)}
\end{align*}

#+BEGIN_SRC octave :exports code :results output :session Q1
clc
clear
close all

if exist('OCTAVE_VERSION', 'builtin')
  set(0, "DefaultLineLineWidth", 2);
  set(0, "DefaultAxesFontSize", 25);
  warning('off');
  pkg load symbolic
end

syms D_2 D_o2 g K_pump V_p C_d t h_2 d_h_2

equ1 = pi/4*D_2*d_h_2 + pi/4*D_o2^2*C_d*sqrt(2*g*h_2) == K_pump*V_p;
equ2 = subs(equ1, d_h_2, 0);
latex(equ2)
equ3 = solve(equ2, V_p);


val_K_pump = 0.0000035;
val_D_o1 = 5e-3;
val_D_o2 = 5e-3;
val_D_2 = 4e-2;
val_C_d = 0.8;
val_g = 9.81;
equ5 = subs(equ3, K_pump, val_K_pump)
equ5 = subs(equ5, D_o2, val_D_o2);
equ5 = subs(equ5, D_2, val_D_2);
equ5 = subs(equ5, C_d, val_C_d);
equ5 = subs(equ5, g, val_g);
equ5 = simplify(equ5);
latex(vpa(equ5))
#+END_SRC

#+RESULTS:
: \frac{\sqrt{2} \pi C_{d} D_{o2}^{2} \sqrt{g h_{2}}}{4} = K_{pump} V_{p}
: equ5 = (sym)
: 
:                    2   ______
:   448799⋅√2⋅C_d⋅Dₒ₂ ⋅╲╱ g⋅h₂ 
:   ───────────────────────────
:                2
: 19.879313473829069834707380973779 h_{2}^{0.5}

** Linearised

\begin{align*}
\frac{dV}{dh} &= \frac{9.94}{\sqrt{h_2} \\
\frac{dV}{dh} |_{h_2=0.1} &= 31.4 \\
V(h_2) \approx V(0.1) + \frac{dV}{dh} |_{h_2=0.1} (h_2 - 0.1) \\
V(h_2) \approx 6.293 + 31.4(h_2 - 0.1)
\end{align*}

* Disturbance
Tank 1 steady state = 7.5cm (h_1) : t = 12.19s, h = 20cm
\[Vol = 0.000318\]
\[q_1 = \frac{0.000318}{12.19} = 2.6086e-5\]

Tank 1 + disturbance steady state (h_1') = 5cm : t = 5.93, h_2 = 11->20cm
\[Vol = pi*(4.5e-2/2)^2 (20-11)*10^-2 = 0.000143138 \]
\[q_2 = 0.000143138/t = 0.00002413808015\]

\[q_{BYP} = q_1 - q_2\]
\[q_{BYP} = 0.00000194791985\]

\[q_{BYP} = C_dCA_o\sqrt{2gh_1^{'}}\]
\[C_d\cdot A_o = \frac{q_{BYP}}{\sqrt{2gh_1^{'}}}\]
\[C_d\cdot A_o = \frac{0.00000194791985}{\sqrt{2*9.81*5e-2}}\]
\[\alpha_{BYP} = C_d\cdot A_o = 0.000\ 001\ 966\ 693\ 034\]
\[q_{BYP} = \alpha_{BYP}\sqrt{2gh}\]

* Noise
|  V | h_1 (cm) | h_2 (cm) |
|  5 |        5 |       10 |
|  7 |        8 |       16 |
| 10 |       13 |       26 |

We can get the following equations that relate the standard deviation to the height in the tank:
\[\begin{cases}
\textrm{std} = 3.88h -0.08 & 0 < h < 0.15 \\
\textrm{std} = 3.90h -0.08 & 0.15 < h < \infty
\end{cases} \approx 3.9h\]


* Part 2 & Controller Design & Evaluation


from the Figure :TODO: we can see that there are poles at $-0.2 + 0j$ and $-0.025 + 0j$. These can be used to create the root locus seen in Figure :TODO:. These will be used in our design for the cascade compensator.




** Cascade Compensator

*** Design Rational
In the non-linear system the calculated feed-forward equation does a very good job at reducing the steady state error. Even though the steady-state error is non-zero it will reduce complexity to have an integrator, so it would be valid to just add another pole.

*** Calculations
**** Design
For a $10\ cm$ step the current system has a settling time of about $150\ s$ and zero overshoot, as seen in Figure :TODO:. To third the settling time and have 10% overshoot a damping ratio of $\zeta = 0.591$ and a natural frequency of $\omega_n = 0.135$.

#+BEGIN_SRC octave :exports code :results output :session Q1
clc
clear
close all

if exist('OCTAVE_VERSION', 'builtin')
  set(0, "DefaultLineLineWidth", 2);
  set(0, "DefaultAxesFontSize", 25);
  warning('off');
  pkg load symbolic
  pkg load control
end

syms z w_n

equ1 = 0.1 == exp(-z*pi/sqrt(1 - z^2));
equ2 = 50 == 4/(z*w_n);

sol = solve([equ1, equ2], [z, w_n]);
z = vpa(sol.z)
w_n = vpa(sol.w_n)


#+END_SRC

#+RESULTS:
#+begin_example
<stdin>-518:7: SymPyDeprecationWarning: 

non-Expr objects in a Matrix is deprecated. Matrix represents
a mathematical matrix. To represent a container of non-numeric
entities, Use a list of lists, TableForm, NumPy array, or some
other data structure instead.

See https://docs.sympy.org/latest/explanation/active-deprecations.html#deprecated-non-expr-in-matrix
for details.

This has been deprecated since SymPy version 1.9. It
will be removed in a future version of SymPy.
z = (sym) 0.59115503379889750930516375129716
w_n = (sym) 0.13532829025560637657003556926944
#+end_example

This allows us to find our design point:
\[s = -0.08 \pm 0.109j\]

#+BEGIN_SRC octave :exports code :results output :session Q1
design_point = -z*w_n + w_n*sqrt(z^2 - 1)
#+END_SRC

#+RESULTS:
: design_point = (sym) -0.08 + 0.10915010830734730779886269003451⋅ⅈ

Next we must find the angles for each pole/zero and use the following equation
\begin{align*}
(2k + 1)180^o &= \sum \theta_z - \sum \theta_p \\
(2k + 1)180^o &= \theta_c -42.3 - 116.7 \\
\Rightarrow \theta_c & = 20.9^o
\end{align*}

#+BEGIN_SRC octave :exports code :results output :session Q1
p1 = -0.2;
p2 = -0.025;

theta_p1 = -vpa(atan2(imag(design_point),(real(design_point) - p1))*180/pi)
theta_p2 = -vpa(atan2(imag(design_point),(real(design_point) - p2))*180/pi)
k = 0;
sum = theta_p1 + theta_p2

#+END_SRC

#+RESULTS:
: theta_p1 = (sym) -42.289160911593302703386170973398
: theta_p2 = (sym) -116.74322538662649613800833633934
: sum = (sym) -159.03238629821979884139450731273

Hence our pole must be at p_c = -0.205$ and our controller will be:
\[C(s) = K(s + 0.205)\]



#+BEGIN_SRC octave :exports code :results output :session Q1
p_c = vpa(imag(design_point)/tand(sum) - real(design_point))
#+END_SRC

#+RESULTS:
: p_c = (sym) 0.36482686374624073498419349846282

We can use the following equation to find $K$.
\[K = \frac{1}{|G(s)C(s)|} = 0.00605\]

#+BEGIN_SRC octave :exports code :results output :session Q1
syms s
G = 1/((s - p1)*(s - p2));
C = 1/(s + p_c);
K = vpa(1/(subs(abs(G*C), s, design_point)))
#+END_SRC

#+RESULTS:
: K = (sym) 0.0060476057495766401129921923145199

**** Pole-Zero Plots
#+BEGIN_SRC octave :exports code :results output :session Q1
close all;

p1 = double(p1);
p2 = double(p2);
p_c = double(p_c);

s = tf('s');
g = 1/((s + -p1)*(s + -p2));
figure;
pzmap(g)
pzmap(C)
xlim([-0.5, 0.1]);
legend('');

#+END_SRC

#+RESULTS:
: error: pzmap: require at least one LTI model
: error: called from
:     pzmap at line 68 column 5

**** Root-Locus
#+BEGIN_SRC octave :exports code :results output :session Q1
close all;
figure;
rlocus(g*C)
hold on;
plot(double(real(design_point)), double(imag(design_point)), 'go', 'MarkerSize', 10, 'DisplayName', 'Design Point');
#+END_SRC

#+RESULTS:
: error: lti: mtimes/mplus: one system is neither an lti system nor a numeric value
: error: called from
:     __numeric_to_lti__ at line 34 column 9
:     __sys_group__ at line 30 column 16
:     mtimes at line 60 column 7

**** Nyquist Diagram
#+BEGIN_SRC octave :exports code :results output :session Q1
close all;
figure;
nyquist(g*C);

%figure;
%nyquist(g*C);
%xlim([-21, -19])
%ylim([-0.1, 0.1])
#+END_SRC

#+RESULTS:
: error: lti: mtimes/mplus: one system is neither an lti system nor a numeric value
: error: called from
:     __numeric_to_lti__ at line 34 column 9
:     __sys_group__ at line 30 column 16
:     mtimes at line 60 column 7

**** System Block Diagrams
:TODO:

*** Analysis
**** Linear
#+BEGIN_SRC octave :exports code :results output :session Q1
close all;
K = double(K)
s = tf('s');
FB = feedback(K*g*C);
[y, t] = step(FB);
figure;
plot(t, y)
#+END_SRC

#+RESULTS:
: K = 6.0476e-03
: error: lti: mtimes/mplus: one system is neither an lti system nor a numeric value
: error: called from
:     __numeric_to_lti__ at line 34 column 9
:     __sys_group__ at line 30 column 16
:     mtimes at line 60 column 7
: error: 'FB' undefined near line 1, column 15
: error: 't' undefined near line 1, column 6

From the step response (Figure :TODO:) we can see that we have reduced the settling time, as desired. As mentioned before there is a steady state-error that can be ignored, because it will be accounted for in the feed-forward term.

**** Non-Linear
:TODO: See Non_Linear_Compensator.slx
The non-linear system exhibits different behaviour, this is because the linear system is an approximation of the non-linear system, this can be seen by comparing the step responses in Figure :TODO: and :TODO:, the non-linear system has no overshoot whereas the linear one does.

By comparing Figures (:TODO: no-feedback) and (:TODO: non-linear feedback) we can see that our goal of reducing the settling time marginally worked. The previous settling time was about 150s and now it is 100s, this is worse than the linear second order estimation but still an improvement. Given that there is no overshoot on the non-linear system it might be feasible to increase the overshoot and re-design the controller, sacrificing overshoot for settling time.

**** Noise
#+BEGIN_SRC octave :exports code :results output :session Q1
hold off;
figure;
bode(FB)
#+END_SRC

#+RESULTS:
: error: 'FB' undefined near line 1, column 6

For the linear system we can see the Bode plot in Figure :TODO:. It can be seen that the system acts as a low pass filter, the system is good at removing high frequency signals, this is good for removing the noise.

**** Disturbances
:TODO: See Non_Linear_Compensator.slx
Adding a disturbance at $t = 100$ effects the system in ways that was not considered in the controller design, this can be seen in Figure :TODO:. 

**** Gain Margin And Phase Margin
The gain and phase margin can be found using the Nyquist diagram, as seen in Figure :TODO:. The Nyquist diagram crosses the real axis at about $-20$, thus the gain can be increase by $\frac{1}{20} = 0.05$ before the system becomes unstable. Hence $G_M = 20\log(0.05) = -60\ dB$.

The phase margin can be found by measuring the angle between the unit circle intercept and the Nyquist diagram. This can be seen in Figure :TODO: and the phase margin can be estimated to be about $\Phi_M = 56^o$.

#+BEGIN_SRC octave :exports code :results output :session Q1
close all;
figure;
hold on;
nyquist(g*C);
xlim([-2, 2]);
ylim([-2, 2]);
theta = 0:0.01:2*pi;
x = cos(theta);
y = sin(theta);
plot(x, y, 'b-', 'DisplayName', 'Unit Circle');  % Plot the unit circle in blue
axis equal;

%angle_degrees = 180 + 56;
%angle_radians = deg2rad(angle_degrees);
%
%line_length = 2;
%x_start = 0;
%y_start = 0;
%x_end = line_length * cos(angle_radians);
%y_end = line_length * sin(angle_radians);
%plot([x_start, x_end], [y_start, y_end], 'r-', 'LineWidth', 2);  % Plot the line in red

hold off;
#+END_SRC

#+RESULTS:
: error: lti: mtimes/mplus: one system is neither an lti system nor a numeric value
: error: called from
:     __numeric_to_lti__ at line 34 column 9
:     __sys_group__ at line 30 column 16
:     mtimes at line 60 column 7

**** Sensitivity
Looking at the root locus in Figure :TODO: we can see that the system might become unstable if the gain is too large, we can look at the sensitivity of the system with respect to the gain to quantify this, we aim to find $S_{T:K}$.

\begin{align*}
S_{T:K} &= \frac{K}{T}\frac{\partial T}{\partial K} \\
S_{T:K} &= \frac{K}{T} \frac{\partial}{\partial K} \left[\frac{1262400 K}{1262400 K + \left(5 s + 1\right) \left(40 s + 1\right) \left(6312 s + 2302.7\right)}\right] \\
S_{T:K} &= \frac{1262400 s^{3} + 744597 s^{2} + 109937 s + 2302}{1262400 K + 1262400 s^{3} + 744597 s^{2} + 109937 s + 2302} \rvert_{K = 0.0060476} \\
S_{T:K} &= \frac{8787566400 s^{3} + 5183143079 s^{2} + 765274475 s + 16029703}{8787566400 s^{3} + 5183143079 s^{2} + 765274475 s + 69173387}
\end{align*}

#+BEGIN_SRC octave :exports code :results output :session Q1
syms s K
G = 1/((s + -p1)*(s + -p2));
C = K/(s + p_c);
T = G*C/(1 + G*C);
T = simplify(T);
latex(vpa(T))
dT_dK = diff(T, K);
T_SK = simplify((K/T)*dT_dK);
%latex(vpa(T_SK));
[num, den] = numden(T_SK);
latex(vpa(expand(num)))
latex(vpa(expand(den)))

T_SK = simplify(subs(T_SK, K, 0.0060476))
[num, den] = numden(T_SK);
latex(vpa(expand(num)))
latex(vpa(expand(den)))

#+END_SRC

#+RESULTS:
#+begin_example
\frac{1262400.0 K}{1262400.0 K + \left(5.0 s + 1.0\right) \left(40.0 s + 1.0\right) \left(6312.0 s + 2302.7874150813184437931175999439\right)}
1262400.0 s^{3} + 744597.48301626368875862351998878 s^{2} + 109937.43367865932997069029199747 s + 2302.7874150813184437931175999439
1262400.0 K + 1262400.0 s^{3} + 744597.48301626368875862351998878 s^{2} + 109937.43367865932997069029199747 s + 2302.7874150813184437931175999439
T_SK = (sym)

        6961⋅(5⋅s + 1)⋅(40⋅s + 1)⋅(6312⋅s + 733⋅π)       
  ───────────────────────────────────────────────────────
  6961⋅(5⋅s + 1)⋅(40⋅s + 1)⋅(6312⋅s + 733⋅π) + 16916160⋅π
8787566400.0 s^{3} + 5183143079.2762115374487783226419 s^{2} + 765274475.83714759592597512259442 s + 16029703.196381057687243891613209
8787566400.0 s^{3} + 5183143079.2762115374487783226419 s^{2} + 765274475.83714759592597512259442 s + 69173387.179330574475996121107707
#+end_example

This sensitivity is only dependent on the input, the plot of this function can be seen in Figure :TODO:. Large values the sensitivity goes to $1$ whereas at zero the sensitivity is $0.2317$, this means that sensitivity will be bounded between $0.2317$ and $1$. Thus, the :TODO:

#+BEGIN_SRC octave :exports code :results output :session Q1
close all;
s = [0:0.00001:20e-2];
Sens = (8787566400.0.*s.^3 + 5183143079.2762115374487783226419.*s.^2 + 765274475.83714759592597512259442.*s + 16029703.196381057687243891613209)./(8787566400.0.*s.^3 + 5183143079.2762115374487783226419.*s.^2 + 765274475.83714759592597512259442.*s + 69173387.179330574475996121107707);
figure;
plot(s, Sens)
Sens(1)
Sens(end)
#+END_SRC

#+RESULTS:
: ans = 0.2317
: ans = 0.8937

** Feedback Compensator

** Nested Control
