:PROPERTIES:
:ID:       30e0f262-edfa-442f-8e1c-7abf03e3ed19
:END:
#+title: ENG331 - Control Systems 1 - Design Task
#+date: [2025-09-23 Tue 12:05]
#+AUTHOR: Baley Eccles - 652137
#+STARTUP: latexpreview
#+FILETAGS: :Assignment:UTAS:2025:
#+LATEX_HEADER: \usepackage[a4paper, margin=1in]{geometry}
#+LATEX_HEADER_EXTRA: \usepackage{minted}
#+LATEX_HEADER_EXTRA: \usepackage{fontspec}
#+LATEX_HEADER_EXTRA: \setmonofont{Iosevka}
#+LATEX_HEADER_EXTRA: \setminted{fontsize=\small, frame=single, breaklines=true}
#+LATEX_HEADER_EXTRA: \usemintedstyle{emacs}
#+LATEX_HEADER_EXTRA: \usepackage{float}
#+LATEX_HEADER_EXTRA: \usepackage[final]{pdfpages}
#+LATEX_HEADER_EXTRA: \setlength{\parindent}{0pt}
#+LATEX_HEADER_EXTRA: \setlength{\parskip}{1em}
#+LATEX_HEADER_EXTRA: \documentclass[12pt]{article}
#+PROPERTY: header-args :eval no

* Feed Forward
** From Data
Data can be collected to create an approximation of a feed forward term, this will provide a reasonable approximation and would be done when an analytical solution is not possible.

*** Real Tanks
|-------------+----------+----------|
| Voltage (V) | h_1 (cm) | h_2 (cm) |
|-------------+----------+----------|
|           5 |      5.5 |     0.11 |
|-------------+----------+----------|
|           7 |        9 |     0.18 |
|-------------+----------+----------|
|          10 |     14.5 |     0.28 |
|-------------+----------+----------|

From the data in the table above the following piece wise function can be obtained which provides the system with the required voltage for a input height.

\[V(h) = \begin{cases}
V = 45.45h           & 0 < h < 0.11 \\
V = 28.57h + 1.86  & 0.11 < h < 0.18 \\
V = 30h + 1.6 & 0.18 < h < \infty
\end{cases}\]

This was tested on the real tanks and in simulation, the simulation has a larger error than in real life.

*** Simulation
The same thing can be redone with data obtained from the non-linear simulation, the data can be seen in the table below.
|-------------+----------|
| Voltage (V) | h_2 (cm) |
|-------------+----------|
|           5 |    0.063 |
|-------------+----------|
|           7 |    0.124 |
|-------------+----------|
|           9 |      0.2 |
|-------------+----------|

As before the data above was used to create the piece wise function seen below.

\[V(h) = \begin{cases}
V = 79.37h           & 0 < h < 0.063 \\
V = 32.79h + 2.937   & 0.063 < h < 0.124 \\
V = 26.32h + 3.73832 & 0.124 < h < \infty
\end{cases}\]



** Non-Linear
We want an equation that is $V_p(t) = f(h_2)$
\begin{align*}
K_{pump}V_p(t) &= \frac{\pi}{4} D_2^2 \frac{dh_2(t)}{dt} + \frac{\pi}{4}D_{o2}^2C_d\sqrt{2gh_2(t)} \\
\textrm{With } \frac{dh_2(t)}{dt} &= 0 \\
K_{pump} V_p &= \frac{\pi C_{d} D_{o2} \sqrt{2g h_{2}}}{4} \\
\Rightarrow V_p(t) &= \frac{\pi C_{d} D_{o2} \sqrt{2g h_{2}}}{4 K_{pump}} \\
\Rightarrow V_p(t) &= 19.8793\sqrt{h_2(t)}
\end{align*}

#+BEGIN_SRC octave :exports none :results output :session FF
clc
clear
close all

if exist('OCTAVE_VERSION', 'builtin')
  set(0, "DefaultLineLineWidth", 2);
  set(0, "DefaultAxesFontSize", 25);
  warning('off');
  pkg load symbolic
end

syms D_2 D_o2 g K_pump V_p C_d t h_2 d_h_2

equ1 = pi/4*D_2*d_h_2 + pi/4*D_o2^2*C_d*sqrt(2*g*h_2) == K_pump*V_p;
equ2 = subs(equ1, d_h_2, 0);
latex(equ2)
equ3 = solve(equ2, V_p);


val_K_pump = 0.0000035;
val_D_o1 = 5e-3;
val_D_o2 = 5e-3;
val_D_2 = 4e-2;
val_C_d = 0.8;
val_g = 9.81;
equ5 = subs(equ3, K_pump, val_K_pump)
equ5 = subs(equ5, D_o2, val_D_o2);
equ5 = subs(equ5, D_2, val_D_2);
equ5 = subs(equ5, C_d, val_C_d);
equ5 = subs(equ5, g, val_g);
equ5 = simplify(equ5);
latex(vpa(equ5))
#+END_SRC

#+RESULTS:
: \frac{\sqrt{2} \pi C_{d} D_{o2}^{2} \sqrt{g h_{2}}}{4} = K_{pump} V_{p}
: equ5 = (sym)
: 
:                    2   ______
:   448799⋅√2⋅C_d⋅Dₒ₂ ⋅╲╱ g⋅h₂ 
:   ───────────────────────────
:                2
: 19.879313473829069834707380973779 h_{2}^{0.5}

** Comparison
To compare the three solutions we can plot them, this can be seen in \ref{fig:fig1}.

#+ATTR_LATEX: :placement [H]
#+CAPTION: Feed Forward Comparison \label{fig:fig1}
[[./ENG331_Design_FF_Comp.png]]

The simulation follows the mathematical solution very closely, they differ a fair bit in the beginning which is due to not recording enough data. This is to be expected, as the simulation is based on the mathematical equations.

The real tanks differ much more than the other two, this is because the real tanks have other losses and things that aren't considered in the simulation. The simulation has worse error on the equations gathered from the real tanks, this lines up with the plot.

#+BEGIN_SRC octave :exports none :results output :session FF
clc
clear
close all

if exist('OCTAVE_VERSION', 'builtin')
  set(0, "DefaultLineLineWidth", 2);
  set(0, "DefaultAxesFontSize", 25);
  warning('off');
end

function V = f1(h)
    V = NaN(size(h)); % Preallocate output array
    V(h >= 0 & h < 0.11) = 45.45 * h(h >= 0 & h < 0.11);
    V(h >= 0.11 & h < 0.18) = 28.57 * h(h >= 0.11 & h < 0.18) + 1.86;
    V(h >= 0.18) = 30 * h(h >= 0.18) + 1.6;
end

function V = f2(h)
    V = NaN(size(h)); % Preallocate output array
    V(h >= 0 & h < 0.063) = 79.37 * h(h >= 0 & h < 0.063);
    V(h > 0.063 & h < 0.124) = 32.79 * h(h > 0.063 & h < 0.124) + 2.937;
    V(h > 0.124) = 26.32 * h(h > 0.124) + 3.73832;
end

h = 0:1e-3:0.2;

V1 = f1(h);
V2 = f2(h);
V3 = 19.879313473829069834707380973779*sqrt(h);
h = h.*1e2;
figure;
plot(h, V1, 'DisplayName', 'Real Tanks');
hold on;
plot(h, V2, 'DisplayName', 'Simulated Tanks');
hold on;
plot(h, V3, 'DisplayName', 'Mathmatical');
legend;
xlabel('height (cm)');
ylabel('Voltage (V)');
title('Feed Forward Comparison');
hold off;
print -dpng 'ENG331_Design_FF_Comp.png'
#+END_SRC

#+RESULTS:

* Disturbance
By considering $q_{BYP} = \alpha_{BYP}\sqrt{2gh}$ we can form an equation for the outflow of the tank, where $\alpha_{BYP} = C_dCA_o$. The first step is to find the outflow of tank 1 with no disturbance ($q_1$), the time for tank 1 to reach steady sate is $12.19\ s$ and is at $7.5\ cm$, which means $q_1 = 0.000\ 026\ 086$. Next we find the outflow of tank 1 with a disturbance, it took $5.93\ s$ to reach steady sate at $5\ cm$, which means $q_1\prime = 0.000\ 024\ 138\ 080\ 150$. Finally

\[\begin{align*}
q_{BYP} &= q_1 - q_1\prime \\
q_{BYP} &= \alpha_{BYP}\sqrt{2gh_1^{'}} \\
\Rightarrow \alpha_{BYP} &= \frac{q_1 - q_1\prime}{\sqrt{2gh_1\prime}} \\
\alpha_{BYP} &= 000\ 001\ 966\ 693\ 034
\end{align*}\]

This can be used in our simulations as a combined constant for or disturbance outflow equation.

* Noise
A ~.mat~ file was obtained from the physical rigs at various heights to get an equation for the noise.
|----+----------+----------|
|  V | h_1 (cm) | h_2 (cm) |
|----+----------+----------|
|  5 |        5 |       10 |
|----+----------+----------|
|  7 |        8 |       16 |
|----+----------+----------|
| 10 |       13 |       26 |
|----+----------+----------|

Using Figure \ref{fig:fig2} and the recorded data we can get the following equation which relates height in tank 2 to the standard deviation of normally distributed noise.

\[N(h) = \begin{cases}
\textrm{std} = 3.88h -0.08 & 0 < h < 0.15 \\
\textrm{std} = 3.90h -0.08 & 0.15 < h < \infty
\end{cases} \approx 3.9h\]


#+ATTR_LATEX: :placement [H]
#+CAPTION: Noise Data \label{fig:fig2}
[[./ENG331_Design_Noise.png]]

#+BEGIN_SRC octave :exports none :results output :session NOISE
clc
clear
close all

if exist('OCTAVE_VERSION', 'builtin')
  set(0, "DefaultLineLineWidth", 2);
  set(0, "DefaultAxesFontSize", 25);
  warning('off');
end

data = csvread('Noise.csv', 1, 0);
t = data(:, 1);
h1 = data(:, 2);
h2 = data(:, 3);
step = data(:, 4);

figure;
plot(t, h1, 'DisplayName', 'h1');
hold on;
plot(t, h2, 'DisplayName', 'h2');
plot(t, step, 'DisplayName', 'step');
hold off;

title('Noise Data');
xlabel('Time (s)');
ylabel('Height (cm)');
legend show;
grid on;
print -dpng 'ENG331_Design_Noise.png'
#+END_SRC

#+RESULTS:

#+BEGIN_SRC octave :exports none :results output :session NOISE
close all;
Fs = 1 / (t(2) - t(1));  % Sampling frequency
N = length(t);           % Number of points
f = (0:N-1)*(Fs/N);      % Frequency vector

H1 = fft(h1);            % FFT of h1
H2 = fft(h2);            % FFT of h2
Hstep = fft(step);       % FFT of step

% Magnitude Spectrum
magnitudeH1 = abs(H1);
magnitudeH2 = abs(H2);

% Plotting Magnitude Spectra
figure;
hold on;
plot(f, magnitudeH1, 'DisplayName', 'Magnitude of h1');
plot(f, magnitudeH2, 'DisplayName', 'Magnitude of h2');
xlim([0,5]);
hold off;
ylim([0, 100])
title('Magnitude Spectrum');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
legend show;
grid on;
print -dpng 'ENG331_Design_Noise_Fourier.png'
#+END_SRC

#+RESULTS:

The Fourier spectrum in Figure \ref{fig:fig3} cannot be used to get any insight into the noise, the sampling frequency of $10\ Hz$ ($5\ Hz$ taking into account Nyquist–Shannon Sampling Theorem ) is too small. There appears to be some notable figures where the noise is jumping up and down, however this is just an artefact of the data recording.

#+ATTR_LATEX: :placement [H]
#+CAPTION: Noise Fourier Spectrum \label{fig:fig3}
[[./ENG331_Design_Noise_Fourier.png]]

For the analysis it will be assumed that the noise is normally distributed. This is valid because of the Central Limit Theorem, the system is summing many distributions of noise from various sources (electrical, magnetic, sensor, human, etc).

It is possible to reduce the noise by adding a filter, although this would have to be accounted for in the controller design. It would have to be a low pass filter, as the noise is high frequency, the cutoff of the filter would determine how much the system is effected, a lower cutoff will have a smaller effect on the system.

* Part 2 & Controller Design & Evaluation
#+BEGIN_SRC octave :exports none :results output :session A
clc
clear
close all

if exist('OCTAVE_VERSION', 'builtin')
  set(0, "DefaultLineLineWidth", 2);
  set(0, "DefaultAxesFontSize", 25);
  warning('off');
  pkg load symbolic
  pkg load control
end

s = tf('s');
p1 = -0.2;
p2 = -0.025;

g = 1/((s + -p1)*(s + -p2));

figure;

% Create a 2x1 subplot layout
subplot(1, 2, 1); % First subplot for pole-zero map
pzmap(g)
xlim([-0.25, 0.1]);
ylim([-1, 1]);
title('Pole-Zero Map');

subplot(1, 2, 2); % Second subplot for root locus
rlocus(g);
title('Root Locus');

% Save the figure as a PNG file
print -dpng 'ENG331_Design_PZ_Rlocus.png';

#+END_SRC

#+RESULTS:

From the Figure \ref{fig:fig4} we can see that there are poles at $-0.2 + 0j$ and $-0.025 + 0j$, which can be used to make the root locus seen on the right. These will be used in our design for the controllers.

#+ATTR_LATEX: :placement [H]
#+CAPTION: Uncompensated System Pole-Zero and Root Locus \label{fig:fig4}
[[./ENG331_Design_PZ_Rlocus.png]]

#+ATTR_LATEX: :placement [H]
#+CAPTION: Uncompensated System Step Response \label{fig:fig5}
[[./ENG331_Design_Step.png]]


#+BEGIN_SRC octave :exports none :results output :session A
close all;
figure;
step(g/200*10e-2)
ylabel('G(s)')
print -dpng 'ENG331_Design_Step.png';
#+END_SRC

#+RESULTS:

** Cascade Compensator

*** Design Rational
In the non-linear system the calculated feed-forward equation does a very good job at reducing the steady state error. Even though the steady-state error is non-zero it will reduce complexity to have an integrator, so it would be valid to just add another pole.

#+ATTR_LATEX: :placement [H]
#+CAPTION: Cascade Compensated System Block Diagram \label{fig:D2}
[[./ENG331_Design_Cascade_Diagram.png]]

*** Design

For a $10\ cm$ step the current system has a settling time of about $150\ s$ and zero overshoot, as seen in Figure \ref{fig:fig5}. To third the settling time and have 10% overshoot a damping ratio of $\zeta = 0.591$ and a natural frequency of $\omega_n = 0.135$ is required.

#+BEGIN_SRC octave :exports none :results output :session Q1
clc
clear
close all

if exist('OCTAVE_VERSION', 'builtin')
  set(0, "DefaultLineLineWidth", 2);
  set(0, "DefaultAxesFontSize", 25);
  warning('off');
  pkg load symbolic
  pkg load control
end

syms z w_n

equ1 = 0.1 == exp(-z*pi/sqrt(1 - z^2));
equ2 = 50 == 4/(z*w_n);

sol = solve([equ1, equ2], [z, w_n]);
z = vpa(sol.z)
w_n = vpa(sol.w_n)


#+END_SRC

#+RESULTS:
: z = (sym) 0.59115503379889750930516375129716
: w_n = (sym) 0.13532829025560637657003556926944

This allows us to find our design point:
\[s = -0.08 \pm 0.109j\]

#+BEGIN_SRC octave :exports none :results output :session Q1
design_point = -z*w_n + w_n*sqrt(z^2 - 1)
#+END_SRC

#+RESULTS:
: design_point = (sym) -0.08 + 0.10915010830734730779886269003451⋅ⅈ

Next we must find the angles for each pole/zero and use the following equation
\begin{align*}
(2k + 1)180^o &= \sum \theta_z - \sum \theta_p \\
(2k + 1)180^o &= \theta_c -42.3 - 116.7 \\
\Rightarrow \theta_c & = 20.9^o
\end{align*}

#+BEGIN_SRC octave :exports none :results output :session Q1
p1 = -0.2;
p2 = -0.025;

theta_p1 = -vpa(atan2(imag(design_point),(real(design_point) - p1))*180/pi)
theta_p2 = -vpa(atan2(imag(design_point),(real(design_point) - p2))*180/pi)
k = 0;
sum = theta_p1 + theta_p2

#+END_SRC

#+RESULTS:
: theta_p1 = (sym) -42.289160911593302703386170973398
: theta_p2 = (sym) -116.74322538662649613800833633934
: sum = (sym) -159.03238629821979884139450731273

Hence our pole must be at p_c = -0.205$ and our controller will be:
\[C(s) = \frac{K}{s + 0.205}\]

#+BEGIN_SRC octave :exports none :results output :session Q1
p_c = vpa(imag(design_point)/tand(sum) - real(design_point))
#+END_SRC

#+RESULTS:
: p_c = (sym) 0.36482686374624073498419349846282

We can use the following equation to find $K$.
\[K = \frac{1}{|G(s)C(s)|} = 0.00605\]

#+BEGIN_SRC octave :exports none :results output :session Q1
syms s

g = 1/((s - p1)*(s - p2));
C = 1/(s + p_c);
K = vpa(1/(subs(abs(g*C), s, design_point)))
#+END_SRC

#+RESULTS:
: K = (sym) 0.0060476057495766401129921923145199

*** Analysis
#+BEGIN_SRC octave :exports none :results output :session Q1
close all;
K = double(K);
s = tf('s');

g = 1/((s - double(p1))*(s - double(p2)));
C = 1/(s + double(p_c));

FB = feedback(K*g*C);
figure;
step(FB);
ylabel('T(s)')
print -dpng 'ENG331_Design_Step_Cascade.png';
#+END_SRC

#+RESULTS:

From the step response (Figure \ref{fig:fig6}) we can see that we have reduced the settling time, as desired. As mentioned before there is a steady state-error that can be ignored, because it will be accounted for in the feed-forward term.

#+ATTR_LATEX: :placement [H]
#+CAPTION: Cascade Compensated System Step Response \label{fig:fig6}
[[./ENG331_Design_Step_Cascade.png]]


The non-linear system exhibits different behaviour, this is because the linear system is an approximation of the non-linear system, this can be seen by comparing the step responses in Figure \ref{fig:fig7} and \ref{fig:fig6}, the non-linear system has no overshoot whereas the linear one does.

#+ATTR_LATEX: :placement [H]
#+CAPTION: Non Linear Cascade Compensated System Step Response \label{fig:fig7}
[[./ENG331_Design_Step_Cascade_NL.png]]

By comparing Figures \ref{fig:fig5} and \ref{fig:fig6} we can see that our goal of reducing the settling time worked. The previous settling time was about 150s and now it is 50s. Given that there is no overshoot on the non-linear system it might be feasible to increase the overshoot and re-design the controller, sacrificing overshoot for settling time.

#+BEGIN_SRC octave :exports none :results output :session Q1
hold off;
figure;
bode(FB)
print -dpng 'ENG331_Design_Bode_Cascade.png';
#+END_SRC

#+RESULTS:

For the linear system we can see the Bode plot in Figure \ref{fig:fig8}. It can be seen that the system acts as a low pass filter, the system is good at attenuating high frequency signals.

#+ATTR_LATEX: :placement [H]
#+CAPTION: Cascade Compensated System Bode Plot \label{fig:fig8}
[[./ENG331_Design_Bode_Cascade.png]]

Adding a disturbance at $t = 100$ effects the system in ways that was not considered in the controller design, this can be seen in Figure \ref{fig:fig9}. This is a particularly bad response because the design rational did not account for steady state error, that was the job of the feed forward term. The response could be improved by adding an integrator, but this would require redesigning the controller.

#+ATTR_LATEX: :placement [H]
#+CAPTION: Non-Linear Cascade Compensated System Disturbance Plot \label{fig:fig9}
[[./ENG331_Design_Disturbance_Cascade.png]]

#+BEGIN_SRC octave :exports none :results output :session Q1
close all;
figure;
subplot(1, 2, 1);
nyquist(g*C);
axis equal;
hold on;
subplot(1, 2, 2);
hold on;
nyquist(g*C);
xlim([-2, 2]);
ylim([-2, 2]);
theta = 0:0.01:2*pi;
x = cos(theta);
y = sin(theta);
plot(x, y, 'b-', 'DisplayName', 'Unit Circle');  % Plot the unit circle in blue
axis equal;

%angle_degrees = 180 + 56;
%angle_radians = deg2rad(angle_degrees);
%
%line_length = 2;
%x_start = 0;
%y_start = 0;
%x_end = line_length * cos(angle_radians);
%y_end = line_length * sin(angle_radians);
%plot([x_start, x_end], [y_start, y_end], 'r-', 'LineWidth', 2);  % Plot the line in red

hold off;
print -dpng 'ENG331_Design_Nyquist_Cascade.png';
#+END_SRC

#+RESULTS:

The gain and phase margin can be found using the Nyquist diagram, as seen in Figure \ref{fig:fig10}. The Nyquist diagram crosses the real axis at about $-20$, thus the gain can be increase by $\frac{1}{20} = 0.05$ before the system becomes unstable. Thus, $G_M = 20\log(0.05) = -60\ dB$.

#+ATTR_LATEX: :placement [H]
#+CAPTION: Cascade Compensated System Nyquist Plot \label{fig:fig10}
[[./ENG331_Design_Nyquist_Cascade.png]]

The phase margin can be found by measuring the angle between the unit circle intercept and the Nyquist diagram. This can be seen in the second plot of Figure \ref{fig:fig10} and the phase margin can be estimated to be about $\Phi_M = 56^o$.

#+BEGIN_SRC octave :exports none :results output :session Q1
close all;
figure;
rlocus(g*C)
hold on;
plot(double(real(design_point)), double(imag(design_point)), 'go', 'MarkerSize', 10, 'DisplayName', 'Design Point');
print -dpng 'ENG331_Design_RLocus_Cascade.png';
#+END_SRC

#+RESULTS:

#+ATTR_LATEX: :placement [H]
#+CAPTION: Cascade Compensated System Root Locus \label{fig:fig11}
[[./ENG331_Design_RLocus_Cascade.png]]

Looking at the root locus in Figure \ref{fig:fig11} we can see that the system might become unstable if the gain is too large, we can look at the sensitivity of the system with respect to the gain to quantify this, we aim to find $S_{T:K}$.

\begin{align*}
S_{T:K} &= \frac{K}{T}\frac{\partial T}{\partial K} \\
S_{T:K} &= \frac{K}{T} \frac{\partial}{\partial K} \left[\frac{1262400 K}{1262400 K + \left(5 s + 1\right) \left(40 s + 1\right) \left(6312 s + 2302.7\right)}\right] \\
S_{T:K} &= \frac{1262400 s^{3} + 744597 s^{2} + 109937 s + 2302}{1262400 K + 1262400 s^{3} + 744597 s^{2} + 109937 s + 2302} \rvert_{K = 0.0060476} \\
S_{T:K} &= \frac{8787566400 s^{3} + 5183143079 s^{2} + 765274475 s + 16029703}{8787566400 s^{3} + 5183143079 s^{2} + 765274475 s + 69173387}
\end{align*}

#+BEGIN_SRC octave :exports none :results output :session Q1
syms s K
G = 1/((s + -p1)*(s + -p2));
C = K/(s + p_c);
T = G*C/(1 + G*C);
T = simplify(T);
latex(vpa(T))
dT_dK = diff(T, K);
T_SK = simplify((K/T)*dT_dK);
%latex(vpa(T_SK));
[num, den] = numden(T_SK);
latex(vpa(expand(num)))
latex(vpa(expand(den)))

T_SK = simplify(subs(T_SK, K, 0.0060476))
[num, den] = numden(T_SK);
latex(vpa(expand(num)))
latex(vpa(expand(den)))

#+END_SRC

#+RESULTS:
#+begin_example
\frac{200.0 K}{200.0 K + \left(s + 0.36482686374624073498419349846282\right) \left(5.0 s + 1.0\right) \left(40.0 s + 1.0\right)}
200.0 s^{3} + 117.96537274924814699683869969256 s^{2} + 17.417208868580833074288707430827 s + 0.36482686374624073498419349846282
200.0 K + 200.0 s^{3} + 117.96537274924814699683869969256 s^{2} + 17.417208868580833074288707430827 s + 0.36482686374624073498419349846282
T_SK = (sym)

      6961⋅(s + 0.36482686374624073498419349846282)⋅(5⋅s + 1)⋅(40⋅s + 1)     
  ───────────────────────────────────────────────────────────────────────────
  6961⋅(s + 0.36482686374624073498419349846282)⋅(5⋅s + 1)⋅(40⋅s + 1) + 2680⋅π
1392200.0 s^{3} + 821156.95970751635124499418855994 s^{2} + 121241.19093419117903012369242599 s + 2539.5597985375817562249709427997
1392200.0 s^{3} + 821156.95970751635124499418855994 s^{2} + 121241.19093419117903012369242599 s + 10959.028110158227635304855209989
#+end_example

This sensitivity is only dependent on the input, the plot of this function can be seen in Figure \ref{fig:fig12}. Large values the sensitivity goes to $1$ whereas at zero the sensitivity is $0.2317$, this means that sensitivity will be bounded between $0.2317$ and $1$. Thus, the sensitivity of $K$ to the input is not an issue.

#+ATTR_LATEX: :placement [H]
#+CAPTION: Cascade Compensated System Sensitivity Plot \label{fig:fig12}
[[./ENG331_Design_Sens_Cascade.png]]


#+BEGIN_SRC octave :exports none :results output :session Q1
close all;
s = [0:0.00001:100e-2];
Sens = (8787566400.0.*s.^3 + 5183143079.2762115374487783226419.*s.^2 + 765274475.83714759592597512259442.*s + 16029703.196381057687243891613209)./(8787566400.0.*s.^3 + 5183143079.2762115374487783226419.*s.^2 + 765274475.83714759592597512259442.*s + 69173387.179330574475996121107707);

figure;
plot(s, Sens);
xlabel('Magnitude');
ylabel('Sensitivity');
title('Sensitivity vs Magnitude');
grid on;
print -dpng 'ENG331_Design_Sens_Cascade.png';
#+END_SRC

#+RESULTS:

** Feedback Compensator
*** Design Rational
Given the results on the non-linear system with the cascade compensator this design will drastically increase overshoot and decrease settling time.

#+ATTR_LATEX: :placement [H]
#+CAPTION: Feedback Compensated System Block Diagram \label{fig:D1}
[[./ENG331_Design_FB_Diagram.png]]

*** Design
If we choose a feedback compensator of the form $C(s) = K_fs$ we can get a non-unity feedback system where $H(s) = K_f\left(s + \frac{1}{K_f}\right)$, this is what we will be using to design the controller.

As before, for a $10\ cm$ step the system has a $150\ s$ settling time and zero overshoot. In the linear system we will aim to reduce the settling time by a factor of three and increase the overshoot to 50%. This gives $\zeta = 0.215$ and $\omega_n = 0.371$.

#+BEGIN_SRC octave :exports none :results output :session FB_C
clc
clear
close all

if exist('OCTAVE_VERSION', 'builtin')
  set(0, "DefaultLineLineWidth", 2);
  set(0, "DefaultAxesFontSize", 25);
  warning('off');
  pkg load symbolic
  pkg load control
end

syms z w_n

equ1 = 0.5 == exp(-z*pi/sqrt(1 - z^2));
equ2 = 50 == 4/(z*w_n);

sol = solve([equ1, equ2], [z, w_n]);
z = vpa(sol.z)
w_n = vpa(sol.w_n)

#+END_SRC

#+RESULTS:
: z = (sym) 0.21545376196624678119163839407970
: w_n = (sym) 0.37130936712320152624721257025123

Thus, our design point is $-0.08 + 0.362j$.
#+BEGIN_SRC octave :exports none :results output :session FB_C
design_point = -z*w_n + w_n*sqrt(z^2 - 1)
#+END_SRC

#+RESULTS:
: design_point = (sym) -0.08 + 0.36258881134617550477021463565733⋅ⅈ

Next we must find the angles for each pole/zero and use the following equation
\begin{align*}
(2k + 1)180^o &= \sum \theta_z - \sum \theta_p \\
(2k + 1)180^o &= \theta_c - 71.68 - 98.62\\
\Rightarrow \theta_c & = 9.7^o
\end{align*}

#+BEGIN_SRC octave :exports none :results output :session FB_C
p1 = -0.2;
p2 = -0.025;

theta_p1 = -vpa(atan2(imag(design_point),(real(design_point) - p1))*180/pi)
theta_p2 = -vpa(atan2(imag(design_point),(real(design_point) - p2))*180/pi)

sum = theta_p1 + theta_p2 + 180
#+END_SRC

#+RESULTS:
: theta_p1 = (sym) -71.687862784313642138789936859293
: theta_p2 = (sym) -98.625271772851647119627184285994
: sum = (sym) 9.6868654428347107415828788547132

Hence our zero must be at $z_c = -2.204$ and our controller will be:
\[C(s) = K_f(s + 2.204)\]

#+BEGIN_SRC octave :exports none :results output :session FB_C
z_c = vpa(imag(design_point)/tand(sum) - real(design_point))
#+END_SRC

#+RESULTS:
: z_c = (sym) 2.2041637863604992379038674772076

We can use the following equation to find $K_f$.
\[K_f = \frac{1}{z_c} = 0.4537\]

#+BEGIN_SRC octave :exports none :results output :session FB_C
syms s
K = double(vpa(1/(z_c)))
1/K
#+END_SRC

#+RESULTS:
: K = 0.4537
: ans = 2.2042

Hence the non-unity feedback controller is:
\[C(s) = 0.4537(s + 2.2042)\]
Or in feedback form:
\[C(s) = 0.4537s\]


*** Analysis

#+BEGIN_SRC octave :exports none :results output :session FB_C
close all;

p1 = double(p1)
p2 = double(p2)
z_c = double(z_c)

s = tf('s');
g = 1/((s + -p1)*(s + -p2));
C = K*s;
G = (g/(1 + g*C))

FB = feedback(G);
figure;
step(FB*10e-2);
xlim([0, 50]);
ylabel('T(s)');
print -dpng 'ENG331_Design_Step_FB.png';

figure;
pzmap(G)
print -dpng 'ENG331_Design_PZ_FB.png';

#+END_SRC

#+RESULTS:
#+begin_example
p1 = -0.2000
p2 = -0.025000
z_c = 2.2042
Transfer function 'G' from input 'u1' to output ...

                     s^2 + 0.225 s + 0.005                
 y1:  ----------------------------------------------------
      s^4 + 0.9037 s^3 + 0.1627 s^2 + 0.004518 s + 2.5e-05

Continuous-time model.
#+end_example

From the step response (Figure \ref{fig:fig14}) we can see that we have increased the overshoot considerably compared to the cascade compensator and reduced the settling time.

#+ATTR_LATEX: :placement [H]
#+CAPTION: Feedback Compensated System Step Response \label{fig:fig14}
[[./ENG331_Design_Step_FB.png]]

From Figure \ref{fig:PZ} it can be seen that there is significant pole zero cancellation, this makes it possible to approximate the system as second order one. The specific second order approximation is, which was achieved by looking at the two free poles in the pole-zero plot:

#+BEGIN_SRC octave :exports none :results output :session FB_C
syms s
G_2 = simplify((s^2 + 0.225*s + 0.005)/(s^4 + 0.9037*s^3 + 0.1627*s^2 + 0.004518*s + 2.5e-05));
[num, den] = numden(G_2);
double(vpa(solve(num, s)));
%double(vpa(solve(den, s)))
%  -0.200000
%  -0.025000

%  -0.67127
%  -0.200000
%  -0.025000
%  -0.007450
latex(vpa(expand((s + 0.67127)*(s + 0.67127))))
#+END_SRC

#+RESULTS:
: s^{2} + 1.3425399855575132042492702583233 s + 0.45060340320519194076276385766326

\[G_{2nd}(s) = \frac{1}{s^{2} + 1.343 s + 0.450}\]

#+ATTR_LATEX: :placement [H]
#+CAPTION: Feedback Compensated System Pole-Zero Plot \label{fig:PZ}
[[./ENG331_Design_PZ_FB.png]]

This system should preform better for the non-linear system, looking at Figure \ref{fig:fig15}, it can be seen that this is not the case. It double the settling time and introduced considerable overshoot. This may be because of how the feedback was simulated, it used a derivative block because just a zero is a non-realisable system, this may have introduced some inconsistencies. However, the differences are way too big for this to be the only reason, there is probably something else that I have not considered.

#+ATTR_LATEX: :placement [H]
#+CAPTION: Non Linear Feedback Compensated System Step Response \label{fig:fig15}
[[./ENG331_Design_FB_Step_NL.png]]

#+BEGIN_SRC octave :exports none :results output :session FB_C
close all;
figure;
subplot(1, 2, 1);
nyquist(G);
axis equal;
hold on;
subplot(1, 2, 2);
hold on;
nyquist(G);
xlim([-2, 2]);
ylim([-2, 2]);
theta = 0:0.01:2*pi;
x = cos(theta);
y = sin(theta);
plot(x, y, 'b-', 'DisplayName', 'Unit Circle');  % Plot the unit circle in blue
axis equal;

%angle_degrees = 180 + 56;
%angle_radians = deg2rad(angle_degrees);
%
%line_length = 2;
%x_start = 0;
%y_start = 0;
%x_end = line_length * cos(angle_radians);
%y_end = line_length * sin(angle_radians);
%plot([x_start, x_end], [y_start, y_end], 'r-', 'LineWidth', 2);  % Plot the line in red

hold off;
print -dpng 'ENG331_Design_Nyquist_FB.png';
#+END_SRC

#+RESULTS:

As seen in Figure \ref{fig:fig16} the gain margin can be calculated to be $G_M = 20\log(\frac{1}{200}) = −106\ dB$, this implies that the system will remain stable for a large amount of gain. Also the phase margin can be seen to be about $\Phi_M = 45^o$.

#+ATTR_LATEX: :placement [H]
#+CAPTION: Feedback Compensated System Nyquist Plot \label{fig:fig16}
[[./ENG331_Design_Nyquist_FB.png]]

** Combined Controller

*** Design Rational
Lets see how the two controllers combined together behave. As both of the controllers are designed to increase the transient performance the two controllers being ran together might be able to increase the performance even more.

#+ATTR_LATEX: :placement [H]
#+CAPTION: Combined Compensated System Block Diagram \label{fig:D3}
[[./ENG331_Design_Combined_Diagram.png]]

*** Analysis

The overall system is given by:
\[T(s) = \frac{s^2 + 0.225 s + 0.005}{s^4 + 0.9037 s^3 + 0.1627 s^2 + 0.004519 s + 2.5\times10^{-5}}\]

#+BEGIN_SRC octave :exports none :results output :session C
clc
clear
close all

if exist('OCTAVE_VERSION', 'builtin')
  set(0, "DefaultLineLineWidth", 2);
  set(0, "DefaultAxesFontSize", 25);
  warning('off');
  pkg load symbolic
  pkg load control
end

p1 = -0.2;
p2 = -0.025;
z_c = 2.2042;

s = tf('s');
g = 1/((s + -p1)*(s + -p2));
C_2 = 0.4537*s;
G = (g/(1 + g*C_2));

FB = feedback(G);

C_1 = 0.00605/(s + 0.205);
Plant = FB*C_1;
T = feedback(Plant);

figure;
step(T)
xlim([0, 50]);
ylabel('T(s)');
print -dpng 'ENG331_Design_Step_Combined.png';

#+END_SRC

#+RESULTS:

Looking at Figure \ref{fig:fig17} we can notice some weird behaviour stemming from the system being higher order. Looking at the pole-zero plot of the combined non-feedback system in Figure \ref{fig:fig18} it can be recognised that we cannot simplify it by approximating it to a second order system.

#+ATTR_LATEX: :placement [H]
#+CAPTION: Combined Compensated System Step Response \label{fig:fig17}
[[./ENG331_Design_Step_Combined.png]]

#+BEGIN_SRC octave :exports none :results output :session C
close all;
figure;
subplot(1, 2, 1);
pzmap(Plant);
xlim([-2, 2]);
ylim([-2, 2]);
axis equal;
subplot(1, 2, 2);
rlocus(Plant);
xlim([-2, 2]);
ylim([-2, 2]);
axis equal;
print -dpng 'ENG331_Design_Combined_PZ_Rlocus.png';
#+END_SRC

#+RESULTS:

#+ATTR_LATEX: :placement [H]
#+CAPTION: Combined System Pole-Zero And Root Locus \label{fig:fig18}
[[./ENG331_Design_Combined_PZ_Rlocus.png]]

#+BEGIN_SRC octave :exports none :results output :session C
close all;
figure;
bode(T)
print -dpng 'ENG331_Design_Combined_Bode.png';
#+END_SRC

#+RESULTS:

#+ATTR_LATEX: :placement [H]
#+CAPTION: Combined System Bode Plot \label{fig:fig20}
[[./ENG331_Design_Combined_Bode.png]]

The Bode plot can be seen in Figure \ref{fig:fig20}, it can be seen that the attenuation start to become significant at $1\ rad/s$, it decreases at a rate of $60\ dB/decade$. This is because the system has poles with complex components of approximately $\pm 1$.

\newpage

* Appendix A - Cascade Compensator Design Code
#+BEGIN_SRC octave :exports code :results output :session Q1 :eval no
clc
clear
close all

if exist('OCTAVE_VERSION', 'builtin')
  set(0, "DefaultLineLineWidth", 2);
  set(0, "DefaultAxesFontSize", 25);
  warning('off');
  pkg load symbolic
  pkg load control
end

syms z w_n

equ1 = 0.1 == exp(-z*pi/sqrt(1 - z^2));
equ2 = 50 == 4/(z*w_n);

sol = solve([equ1, equ2], [z, w_n]);
z = vpa(sol.z)
w_n = vpa(sol.w_n)
#+END_SRC

#+BEGIN_SRC octave :exports code :results output :session Q1 :eval no
design_point = -z*w_n + w_n*sqrt(z^2 - 1)
#+END_SRC

#+BEGIN_SRC octave :exports code :results output :session Q1 :eval no
p1 = -0.2;
p2 = -0.025;

theta_p1 = -vpa(atan2(imag(design_point),(real(design_point) - p1))*180/pi)
theta_p2 = -vpa(atan2(imag(design_point),(real(design_point) - p2))*180/pi)
k = 0;
sum = theta_p1 + theta_p2
#+END_SRC

#+BEGIN_SRC octave :exports code :results output :session Q1 :eval no
p_c = vpa(imag(design_point)/tand(sum) - real(design_point))
#+END_SRC

#+BEGIN_SRC octave :exports code :results output :session Q1 :eval no
syms s

g = 1/((s - p1)*(s - p2));
C = 1/(s + p_c);
K = vpa(1/(subs(abs(g*C), s, design_point)))
#+END_SRC


* Appendix A - Feedback Compensator Design Code
#+BEGIN_SRC octave :exports code :results output :session FB_C :eval no
clc
clear
close all

if exist('OCTAVE_VERSION', 'builtin')
  set(0, "DefaultLineLineWidth", 2);
  set(0, "DefaultAxesFontSize", 25);
  warning('off');
  pkg load symbolic
  pkg load control
end

syms z w_n

equ1 = 0.5 == exp(-z*pi/sqrt(1 - z^2));
equ2 = 50 == 4/(z*w_n);

sol = solve([equ1, equ2], [z, w_n]);
z = vpa(sol.z)
w_n = vpa(sol.w_n)
#+END_SRC

#+BEGIN_SRC octave :exports code :results output :session FB_C :eval no
design_point = -z*w_n + w_n*sqrt(z^2 - 1)
#+END_SRC

#+BEGIN_SRC octave :exports code :results output :session FB_C :eval no
p1 = -0.2;
p2 = -0.025;

theta_p1 = -vpa(atan2(imag(design_point),(real(design_point) - p1))*180/pi)
theta_p2 = -vpa(atan2(imag(design_point),(real(design_point) - p2))*180/pi)

sum = theta_p1 + theta_p2 + 180
#+END_SRC

#+BEGIN_SRC octave :exports code :results output :session FB_C :eval no
z_c = vpa(imag(design_point)/tand(sum) - real(design_point))
#+END_SRC

#+BEGIN_SRC octave :exports code :results output :session FB_C :eval no
syms s
K = double(vpa(1/(z_c)))
1/K
#+END_SRC

