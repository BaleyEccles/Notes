:PROPERTIES:
:ID:       4e1476b3-c09e-4372-81de-a54b491d8a1d
:END:
#+title: ENG308 - Communication Systems 1 - Assignment 1
#+date: [2025-03-13 Thu 12:32]
#+AUTHOR: Baley Eccles - 652137
#+FILETAGS: :UTAS:2025:
#+STARTUP: latexpreview

* ENG308 - Communication Systems 1 - Assignment 1
** Question 1
*** Part a
Take:
\begin{table}[htbp]
  \centering
  \caption{Chosen Values}
  \begin{tabular}{|c|c|c|}
    \hline
    $A_1 = 5$ & $A_2 = 20$ & $A_3 = 10$ \\ \hline
    $f_1 = 50$ & $f_2 = 100 & $f_3 = 150$ \\ \hline
    $\phi_1 = \frac{\pi}{2}$ & $\phi_2 = \pi$ & $\phi_3 = \frac{\pi}{3}$ \\ 
    \hline
  \end{tabular}
  \label{tab:Chosen_Values}
\end{table}
\[\Rightarrow m(t) = 5\cos\left(2\pi 50t + \frac{\pi}{2}\right) + 20\cos\left(2\pi 100t + \pi\right) + 10\cos\left(2\pi 150t + \frac{\pi}{3}\right)\]
Taking $A_c = 1$, $f_c = 50$Hz and $\phi_c = 0$
**** DSB-SC AM
\begin{align*}
  c(t) &= A_c\cos(2\pi f_c t + \phi_c) \\
  &\textrm{Taking } A_c = 1\textrm{, } f_c = 250 \textrm{ and } \phi_c = 0 \\
  u(t) &= m(t) \cdot c(t) \\
  u(t) &= \left[5\cos\left(6\pi + \frac{\pi}{2}\right) +
  10\cos\left(60\pi + \pi\right) +
  20\cos\left(200\pi + \frac{\pi}{3}\right)\right]
  \cdot A_c\cos(2\pi f_c t + \phi_c) \\
\end{align*}

#+BEGIN_SRC octave :exports code :results output :session DSB_SC
clear all;
close all;

fc = 250;
Fs = 1000*fc;
t = 0:1/(Fs):0.2;

% Values
A1 = 5;
A2 = 20;
A3 = 10;
w = 2*pi;
f1 = 50;
f2 = 100;
f3 = 150;
phi1 = pi/2;
phi2 = pi;
phi3 = pi/3;


m = A1*cos(w*f1*t + phi1) + A2*cos(w*f2*t + phi2) + A3*cos(w*f3*t + phi3);
c = cos(2*pi * fc * t);
u = m.*c;

figure;
grid on;
plot(t, u);
title('DSB-SC Modulated Signal');
xlabel('Time (s)');
ylabel('Amplitude');
print -dpng 'DSB_SC_plot_time.png'

N = length(t);
f = (-N/2:N/2-1)*(Fs/N);

U = fftshift(fft(u));
mag = abs(U);
angle = angle(U);

figure;
grid on;
plot(f, mag);
title('Magnitude of DSB-SC Signal');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
xlim([-1000 1000]);
print -dpng 'DSB_SC_plot_f_mag.png'

figure;
grid on;
plot(f, mag/max(mag));
title('Magnitude of DSB-SC Signal');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
xlim([fc - 1.25*max([f1, f2, f3]), fc + 1.25*max([f1, f2, f3])]);
print -dpng 'DSB_SC_plot_f_mag_centered.png'

figure;
grid on;
plot(f, angle);
title('Phase of DSB-SC Signal');
xlabel('Frequency (Hz)');
ylabel('Phase (radians)');
%xlim([fc-150 fc+150]);
print -dpng 'DSB_SC_plot_f_angle.png'

#+END_SRC

#+RESULTS:
**** Conventional AM/DSB AM
\begin{align*}
  c(t) &= A_c\cos(2\pi f_c t + \phi_c) \\
  &\textrm{Taking } A_c = 1\textrm{, } f_c = 250 \textrm{ and } \phi_c = 0 \\
  u(t) &= (1 + m(t)) \cdot c(t) \\
  u(t) &= (1 + 5\cos\left(2\pi 50t + \frac{\pi}{2}\right) + 20\cos\left(2\pi 100t + \pi\right) + 10\cos\left(2\pi 150t + \frac{\pi}{3}\right)) \cdot \cos(2\pi 250 t)
\end{align*}

#+BEGIN_SRC octave :exports code :results output :session DSB
clear all;
close all;

fc = 250;
Fs = 1000*fc;
t = 0:1/(Fs):0.2;

% Values
A1 = 5;
A2 = 20;
A3 = 10;
w = 2*pi;
f1 = 50;
f2 = 100;
f3 = 150;
phi1 = pi/2;
phi2 = pi;
phi3 = pi/3;


m = A1*cos(w*f1*t + phi1) + A2*cos(w*f2*t + phi2) + A3*cos(w*f3*t + phi3);
c = cos(2*pi * fc * t);
u = (1 + m).*c;

figure;
grid on;
plot(t, u);
title('DSB Modulated Signal');
xlabel('Time (s)');
ylabel('Amplitude');
print -dpng 'DSB_plot_time.png'

N = length(t);

f = (-N/2:N/2-1)*(Fs/N);

U = fftshift(fft(u));
mag = abs(U);
angle = angle(U);

figure;
grid on;
plot(f, mag);
title('Magnitude of DSB Signal');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
xlim([-1000 1000]);
print -dpng 'DSB_plot_f_mag.png'

figure;
grid on;
plot(f, mag/max(mag));
title('Magnitude of DSB Signal');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
xlim([fc - 1.25*max([f1, f2, f3]), fc + 1.25*max([f1, f2, f3])]);
print -dpng 'DSB_plot_f_mag_centered.png'

figure;
grid on;
plot(f, angle);
title('Phase of DSB Signal');
xlabel('Frequency (Hz)');
ylabel('Phase (radians)');
%xlim([fc-150 fc+150]);
print -dpng 'DSB_plot_f_angle.png'

#+END_SRC

#+RESULTS:
**** SSB AM
:FIXME: THIS MIGHT BE WRONG
\begin{align*}
  c(t) &= A_c\cos(2\pi f_c t + \phi_c) \\
  &\textrm{Taking } A_c = 1\textrm{, } f_c = 250 \textrm{ and } \phi_c = 0 \\
  u(t) &= m(t)\cdot c(t) \mp \hat{m}(t)\cdot c(t) \\
  &\textrm{Taking the negative variant/upper side band (USB)} \\
  \hat{m}(t) &= m(t) * \frac{1}{\pi t}\\
  u(t) &= \left[5\cos\left(2\pi 50t + \frac{\pi}{2}\right) + 20\cos\left(2\pi 100t + \pi\right) + 10\cos\left(2\pi 150t + \frac{\pi}{3}\right) \right]
  \cdot \cos(2\pi 250 t) \\
  &- \left[\left[5\cos\left(2\pi 50t + \frac{\pi}{2}\right) + 20\cos\left(2\pi 100t + \pi\right) + 10\cos\left(2\pi 150t + \frac{\pi}{3}\right) \right] * \frac{1}{\pi t} \right]\cdot
  \cos(2\pi 250 t)
\end{align*}
The Lower Side Band (LSB) could be found by taking the positive variant.

#+BEGIN_SRC octave :exports code :results output :session SSB
clear all;
close all;

% make compatible with matlab
% This way if we run this in matlab it wont throw an error
if exist('OCTAVE_VERSION', 'builtin')
  % needed for Hilbert transform
  pkg load signal
end

fc = 250;
Fs = 1000*fc;
t = 0:1/(Fs):0.2;

% Values
A1 = 5;
A2 = 20;
A3 = 10;
f1 = 50;
f2 = 100;
f3 = 150;
phi1 = pi/2;
phi2 = pi;
phi3 = pi/3;
w = 2*pi;

m = A1*cos(w*f1*t + phi1) + A2*cos(w*f2*t + phi2) + A3*cos(w*f3*t + phi3);
c_cos = cos(2*pi * fc * t);
c_sin = sin(2*pi * fc * t);
u = m.*c_cos - imag(hilbert(m)).*c_sin; % This is wrong some how

figure;
grid on;
plot(t, u);
title('SSB (LSB) Modulated Signal');
xlabel('Time (s)');
ylabel('Amplitude');
print -dpng 'SSB_plot_time.png'

N = length(t);

f = (-N/2:N/2-1)*(Fs/N);

U = fftshift(fft(u));
mag = abs(U);
angle = angle(U);

figure;
grid on;
plot(f, mag);
title('Magnitude of SSB (LSB) Signal');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
xlim([-1000 1000]);
print -dpng 'SSB_plot_f_mag.png'

figure;
grid on;
plot(f, mag/max(mag));
title('Magnitude of SSB (LSB) Signal');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
xlim([fc - 1.25*max([f1, f2, f3]), fc + 1.25*max([f1, f2, f3])]);
print -dpng 'SSB_plot_f_mag_centered.png'

figure;
grid on;
plot(f, angle);
title('Phase of SSB (LSB) Signal');
xlabel('Frequency (Hz)');
ylabel('Phase (radians)');
%xlim([fc-150 fc+150]);
print -dpng 'SSB_plot_f_angle.png'

#+END_SRC

#+RESULTS:
**** TODO Comparing

*** Part b


#+BEGIN_SRC falstad
$ 1 0.000005 10.20027730826997 50 5 43 5e-11
c 256 192 256 352 4 0.00001 16.608892077919815 0.001 0
r 352 192 352 352 0 1000
w 256 352 352 352 0
w 352 192 256 192 0
w 256 352 48 352 0
w 352 352 400 352 0
w 352 192 400 192 0
v 48 352 48 304 0 1 50 5 0 1.5707963267948966 0.5
v 48 304 48 256 0 1 100 20 0 3.141592653589793 0.5
v 48 256 48 192 0 1 150 10 0 1.0471975511965976 0.5
g 256 352 256 384 0 0
w 48 192 80 192 0
d 80 192 256 192 2 default
o 6 1024 0 4099 80 0.05 0 2 6 3
#+END_SRC

#+BEGIN_SRC octave :exports code :results output :session Demodulation

clear all;
close all;

%% Filter
% Have to do this cause octave does not have lowpass function
function y = lowpassOctave (r, fs, fc)
  N = length(r);
  f = (0:N-1) * (fs/N);
  mask = (f <= fc) | (f >= (fs - fc));
  R = fft(r);
  R(~mask) = 0;
  y = ifft(R);  
end

if exist('OCTAVE_VERSION', 'builtin')
                                % needed for Butterworth filter
  pkg load signal
end

fc = 250;
Fs = 1000*fc;
t = 0:1/(Fs):0.2;

                                % Values
A1 = 5;
A2 = 20;
A3 = 10;
w = 2*pi;
f1 = 50;
f2 = 100;
f3 = 150;
phi1 = pi/2;
phi2 = pi;
phi3 = pi/3;


m_DSB = A1*cos(w*f1*t + phi1) + A2*cos(w*f2*t + phi2) + A3*cos(w*f3*t + phi3);
c_DSB = cos(2*pi * fc * t);
u_DSB = m_DSB.*c_DSB;

m_SSB = A1*cos(w*f1*t + phi1) + A2*cos(w*f2*t + phi2) + A3*cos(w*f3*t + phi3);
c_cos = cos(2*pi * fc * t);
c_sin = sin(2*pi * fc * t);
u_SSB = m_SSB.*c_cos - imag(hilbert(m_SSB)).*c_sin;



figure;
grid on;
plot(t, m_DSB);
title('DSB-SC Message Signal');
xlabel('Time (s)');
ylabel('Amplitude');
print -dpng 'DSB_SC_plot_time_message.png'

figure;
grid on;
plot(t, m_SSB);
title('SSB Message Signal');
xlabel('Time (s)');
ylabel('Amplitude');
print -dpng 'SSB_plot_time_message.png'

D_phi = 0;
D_f = 0;
local_oscillator = cos(2*pi * (fc + D_f) * t + D_phi);

r_DSB = u_DSB.*local_oscillator;
r_SSB = u_SSB.*local_oscillator;

N = length(t);

% Define the useage of lowpassOctave if we are using octave
% And lowpass if your using matlab
if exist('OCTAVE_VERSION', 'builtin')
  y_DSB = lowpassOctave(r_DSB, Fs, 1.1*fc);
  y_SSB = lowpassOctave(r_SSB, Fs, 1.1*fc);
else
  y_DSB = lowpass(r_DSB, 1.1*fc, Fs);
  y_SSB = lowpass(r_SSB, 1.1*fc, Fs);
end


figure;
grid on;
plot(t, y_DSB);
title('DSB-SC Demodulated Signal');
xlabel('Time (s)');
ylabel('Amplitude');
print -dpng 'DSB_SC_plot_time_demodulated.png'

figure;
grid on;
plot(t, y_SSB);
title('SSB Demodulated Signal');
xlabel('Time (s)');
ylabel('Amplitude');
print -dpng 'SSB_plot_time_demodulated.png'

#+END_SRC

#+RESULTS:

:TODO: Theoretically

*** Part c


#+BEGIN_SRC octave :exports code :results output :session test
if exist('OCTAVE_VERSION', 'builtin')
  pkg load symbolic
end

fc = 25000;
Fs = 1000*fc;


% Values
A1 = 5;
A2 = 20;
A3 = 10;
f1 = 50;
f2 = 100;
f3 = 150;
phi1 = pi/2;
phi2 = pi;
phi3 = pi/3;
w = 2*pi;

syms time

m = A1*cos(w*f1*time + phi1) + A2*cos(w*f2*time + phi2) + A3*cos(w*f3*time + phi3);
c = cos(2*pi * fc * time);
u = (1 + m).*c
sympref display flat;
expand(u);

#+END_SRC

#+RESULTS:
#+begin_example
warning: passing floating-point values to sym is dangerous, see "help sym"
warning: called from
    double_to_sym_heuristic at line 50 column 7
    sym at line 384 column 13
    mtimes at line 54 column 5

warning: passing floating-point values to sym is dangerous, see "help sym"
warning: called from
    double_to_sym_heuristic at line 50 column 7
    sym at line 384 column 13
    plus at line 53 column 5

warning: passing floating-point values to sym is dangerous, see "help sym"
warning: called from
    double_to_sym_heuristic at line 50 column 7
    sym at line 384 column 13
    mtimes at line 54 column 5

warning: passing floating-point values to sym is dangerous, see "help sym"
warning: called from
    double_to_sym_heuristic at line 50 column 7
    sym at line 384 column 13
    mtimes at line 54 column 5

warning: passing floating-point values to sym is dangerous, see "help sym"
warning: called from
    double_to_sym_heuristic at line 50 column 7
    sym at line 384 column 13
    plus at line 53 column 5
warning: passing floating-point values to sym is dangerous, see "help sym"
warning: called from
    double_to_sym_heuristic at line 50 column 7
    sym at line 384 column 13
    mtimes at line 54 column 5
u = (sym) (-5*sin(26*sqrt(146)*time) - 20*cos(52*sqrt(146)*time) + 10*cos(78*sqrt(146)*time + pi/3) + 1)*cos(sqrt(24674011003)*time)
#+end_example


#+BEGIN_SRC octave :exports code :results output :session AM_Demodulation
clear all;
close all;

if exist('OCTAVE_VERSION', 'builtin')
  % needed for findpeaks
  pkg load signal
end

fc = 2500;
Fs = 1000*fc;
t = 0:1/(Fs):0.1;

% Values
A1 = 5;
A2 = 20;
A3 = 10;
f1 = 50;
f2 = 100;
f3 = 150;
phi1 = pi/2;
phi2 = pi;
phi3 = pi/3;
w = 2*pi;

m = A1*cos(w*f1*t + phi1) + A2*cos(w*f2*t + phi2) + A3*cos(w*f3*t + phi3);
c = cos(2*pi * fc * t);
u = (1 + m).*c;

figure;
grid on;
plot(t, u, t, m);
title('DSB Modulated Signal');
xlabel('Time (s)');
ylabel('Amplitude');

[pks, idx] = findpeaks(u, "DoubleSided");
E_max = max(abs(pks));
E_min = min(abs(pks));
a = (E_max - E_min)/(E_max + E_min);
printf("the modulation index is %f \n", a)

#+END_SRC

#+RESULTS:
: the modulation index is 0.991802


**** Envelope Detector
We want $f_c < \frac{1}{RC} < f_m$
