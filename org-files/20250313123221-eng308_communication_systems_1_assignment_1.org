:PROPERTIES:
:ID:       4e1476b3-c09e-4372-81de-a54b491d8a1d
:END:
#+title: ENG308 - Communication Systems 1 - Assignment 1
#+date: [2025-03-13 Thu 12:32]
#+AUTHOR: Baley Eccles - 652137
#+FILETAGS: :UTAS:2025:
#+STARTUP: latexpreview

* ENG308 - Communication Systems 1 - Assignment 1
** Question 1
*** Part a
Take:
\begin{table}[htbp]
  \centering
  \caption{Chosen Values}
  \begin{tabular}{|c|c|c|}
    \hline
    $A_1 = 5$ & $A_2 = 20$ & $A_3 = 10$ \\ \hline
    $f_1 = 50$ & $f_2 = 100 & $f_3 = 150$ \\ \hline
    $\phi_1 = \frac{\pi}{2}$ & $\phi_2 = \pi$ & $\phi_3 = \frac{\pi}{3}$ \\ 
    \hline
  \end{tabular}
  \label{tab:Chosen_Values}
\end{table}
\[\Rightarrow m(t) = 5\cos\left(2\pi 50t + \frac{\pi}{2}\right) + 20\cos\left(2\pi 100t + \pi\right) + 10\cos\left(2\pi 150t + \frac{\pi}{3}\right)\]
Taking $A_c = 1$, $f_c = 1000$ Hz and $\phi_c = 0$

**** DSB-SC AM
\begin{align*}
  c(t) &= A_c\cos(2\pi f_c t + \phi_c) \\
  u(t) &= m(t) \cdot c(t) \\
  u(t) &= \left[5\cos\left(6\pi + \frac{\pi}{2}\right) +
  10\cos\left(60\pi + \pi\right) +
  20\cos\left(200\pi + \frac{\pi}{3}\right)\right]
  \cdot A_c\cos(2\pi f_c t + \phi_c) \\
\end{align*}

#+BEGIN_SRC octave :exports none :results output :session DSB_SC
clear all;
close all;

fc = 1000;
Fs = 1000*fc;
t = 0:1/(Fs):0.25;

%% Values
A1 = 5;
A2 = 20;
A3 = 10;
f1 = 50;
f2 = 100;
f3 = 150;
phi1 = pi/2;
phi2 = pi;
phi3 = pi/3;
w = 2*pi;


m = A1*cos(w*f1*t + phi1) + A2*cos(w*f2*t + phi2) + A3*cos(w*f3*t + phi3);
c = cos(2*pi * fc * t);
u = m.*c;

figure;
grid on;
plot(t, u, 'LineWidth', 2, t, m, 'LineWidth', 2);
title('DSB-SC Modulated Signal');
xlabel('Time (s)');
ylabel('Amplitude');
xlim([0, 0.075]);
print -dpng 'DSB_SC_plot_time.png'

N = length(t);
f = (-N/2:N/2-1)*(Fs/N);

U = fftshift(fft(u));
mag = abs(U);
angle = angle(U);

figure;
grid on;
plot(f, mag, 'LineWidth', 2);
title('Magnitude of DSB-SC Signal');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
xlim([-fc - 200, fc + 200]);
print -dpng 'DSB_SC_plot_f_mag.png'

figure;
grid on;
plot(f, mag/max(mag), 'LineWidth', 2);
title('Magnitude of DSB-SC Signal');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
xlim([fc - 1.25*max([f1, f2, f3]), fc + 1.25*max([f1, f2, f3])]);
print -dpng 'DSB_SC_plot_f_mag_centered.png'

figure;
grid on;
plot(f, angle, 'LineWidth', 2);
title('Phase of DSB-SC Signal');
xlabel('Frequency (Hz)');
ylabel('Phase (radians)');
%%xlim([-fc - 200, fc + 200]);
print -dpng 'DSB_SC_plot_f_angle.png'

#+END_SRC

#+RESULTS:
**** Conventional AM/DSB AM
\begin{align*}
  c(t) &= A_c\cos(2\pi f_c t + \phi_c) \\
  u(t) &= (1 + m(t)) \cdot c(t) \\
  u(t) &= (1 + 5\cos\left(2\pi 50t + \frac{\pi}{2}\right) + 20\cos\left(2\pi 100t + \pi\right) + 10\cos\left(2\pi 150t + \frac{\pi}{3}\right)) \cdot \cos(2\pi 1000 t)
\end{align*}

#+BEGIN_SRC octave :exports none :results output :session DSB
clear all;
close all;

fc = 1000;
Fs = 1000*fc;
t = 0:1/(Fs):0.25;

%% Values
A1 = 5;
A2 = 20;
A3 = 10;
f1 = 50;
f2 = 100;
f3 = 150;
phi1 = pi/2;
phi2 = pi;
phi3 = pi/3;
w = 2*pi;

m = A1*cos(w*f1*t + phi1) + A2*cos(w*f2*t + phi2) + A3*cos(w*f3*t + phi3);
c = cos(2*pi * fc * t);
u = (1 + m).*c;

figure;
grid on;
plot(t, u, 'LineWidth', 2, t, m, 'LineWidth', 2);
title('DSB Modulated Signal');
xlabel('Time (s)');
ylabel('Amplitude');
xlim([0, 0.075]);
print -dpng 'DSB_plot_time.png'

N = length(t);

f = (-N/2:N/2-1)*(Fs/N);

U = fftshift(fft(u));
mag = abs(U);
angle = angle(U);

figure;
grid on;
plot(f, mag, 'LineWidth', 2);
title('Magnitude of DSB Signal');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
xlim([-1000 1000]);
print -dpng 'DSB_plot_f_mag.png'

figure;
grid on;
plot(f, mag/max(mag), 'LineWidth', 2);
title('Magnitude of DSB Signal');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
xlim([fc - 1.25*max([f1, f2, f3]), fc + 1.25*max([f1, f2, f3])]);
print -dpng 'DSB_plot_f_mag_centered.png'

figure;
grid on;
plot(f, angle, 'LineWidth', 2);
title('Phase of DSB Signal');
xlabel('Frequency (Hz)');
ylabel('Phase (radians)');
%%xlim([fc-150 fc+150]);
print -dpng 'DSB_plot_f_angle.png'

#+END_SRC

#+RESULTS:
**** SSB AM
\begin{align*}
  c(t) &= A_c\cos(2\pi f_c t + \phi_c) \\
  u(t) &= m(t)\cdot c(t) \mp \hat{m}(t)\cdot c(t) \\
  &\textrm{Taking the negative variant/upper side band (USB)} \\
  \hat{m}(t) &= m(t) * \frac{1}{\pi t}\\
  u(t) &= \left[5\cos\left(2\pi 50t + \frac{\pi}{2}\right) + 20\cos\left(2\pi 100t + \pi\right) + 10\cos\left(2\pi 150t + \frac{\pi}{3}\right) \right]
  \cdot \cos(2\pi 1000 t) \\
  &- \left[\left[5\cos\left(2\pi 50t + \frac{\pi}{2}\right) + 20\cos\left(2\pi 100t + \pi\right) + 10\cos\left(2\pi 150t + \frac{\pi}{3}\right) \right] * \frac{1}{\pi t} \right]\cdot
  \cos(2\pi 1000 t)
\end{align*}
The Lower Side Band (LSB) could be found by taking the positive variant.

#+BEGIN_SRC octave :exports none :results output :session SSB
clear all;
close all;

%% make compatible with matlab
%% This way if we run this in matlab it wont throw an error
if exist('OCTAVE_VERSION', 'builtin')
  %% needed for Hilbert transform
  pkg load signal
end


fc = 1000;
Fs = 1000*fc;
t = 0:1/(Fs):0.25;

%% Values
A1 = 5;
A2 = 20;
A3 = 10;
f1 = 50;
f2 = 100;
f3 = 150;
phi1 = pi/2;
phi2 = pi;
phi3 = pi/3;
w = 2*pi;

m = A1*cos(w*f1*t + phi1) + A2*cos(w*f2*t + phi2) + A3*cos(w*f3*t + phi3);
c_cos = cos(2*pi * fc * t);
c_sin = sin(2*pi * fc * t);
u = m.*c_cos - imag(hilbert(m)).*c_sin;

figure;
grid on;
plot(t, u, 'LineWidth', 2, t, m, 'LineWidth', 2);
title('SSB (LSB) Modulated Signal');
xlabel('Time (s)');
ylabel('Amplitude');
xlim([0, 0.075]);
print -dpng 'SSB_plot_time.png'

N = length(t);

f = (-N/2:N/2-1)*(Fs/N);

U = fftshift(fft(u));
mag = abs(U);
angle = angle(U);

figure;
grid on;
plot(f, mag, 'LineWidth', 2);
title('Magnitude of SSB (LSB) Signal');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
xlim([-fc - 200, fc + 200]);
print -dpng 'SSB_plot_f_mag.png'

figure;
grid on;
plot(f, mag/max(mag), 'LineWidth', 2);
title('Magnitude of SSB (LSB) Signal');
xlabel('Frequency (Hz)');
ylabel('Magnitude');
xlim([fc - 1.25*max([f1, f2, f3]), fc + 1.25*max([f1, f2, f3])]);
print -dpng 'SSB_plot_f_mag_centered.png'

figure;
grid on;
plot(f, angle, 'LineWidth', 2);
title('Phase of SSB (LSB) Signal');
xlabel('Frequency (Hz)');
ylabel('Phase (radians)');
%%xlim([fc-150 fc+150]);
print -dpng 'SSB_plot_f_angle.png'

#+END_SRC

#+RESULTS:
**** TODO Comparing

*** Part b
#+BEGIN_SRC octave :exports none :results output :session Demodulation

clear all;
close all;

%% Filter
%% Have to do this cause octave does not have lowpass function
function y = lowpassOctave (r, fs, fc)
  N = length(r);
  f = (0:N-1) * (fs/N);
  mask = (f <= fc) | (f >= (fs - fc));
  R = fft(r);
  R(~mask) = 0;
  y = ifft(R);  
end

if exist('OCTAVE_VERSION', 'builtin')
  %% needed for Butterworth filter
  pkg load signal
end

fc = 1000;
Fs = 1000*fc;
t = 0:1/(Fs):0.2;

%% Values
A1 = 5;
A2 = 20;
A3 = 10;
w = 2*pi;
f1 = 50;
f2 = 100;
f3 = 150;
phi1 = pi/2;
phi2 = pi;
phi3 = pi/3;


m_DSB = A1*cos(w*f1*t + phi1) + A2*cos(w*f2*t + phi2) + A3*cos(w*f3*t + phi3);
c_DSB = cos(2*pi * fc * t);
u_DSB = m_DSB.*c_DSB;

m_SSB = A1*cos(w*f1*t + phi1) + A2*cos(w*f2*t + phi2) + A3*cos(w*f3*t + phi3);
c_cos = cos(2*pi * fc * t);
c_sin = sin(2*pi * fc * t);
u_SSB = m_SSB.*c_cos - imag(hilbert(m_SSB)).*c_sin;


D_phi = 0;
D_f = 0;
local_oscillator = cos(2*pi * (fc + D_f) * t + D_phi);

r_DSB = u_DSB.*local_oscillator;
r_SSB = u_SSB.*local_oscillator;

N = length(t);

%% Define the useage of lowpassOctave if we are using octave
%% And lowpass if your using matlab
if exist('OCTAVE_VERSION', 'builtin')
  y_DSB = lowpassOctave(r_DSB, Fs, 1.1*fc);
  y_SSB = lowpassOctave(r_SSB, Fs, 1.1*fc);
else
  y_DSB = lowpass(r_DSB, 1.1*fc, Fs);
  y_SSB = lowpass(r_SSB, 1.1*fc, Fs);
end


figure;
grid on;
plot(t, y_DSB, 'LineWidth', 2);
title('DSB-SC Demodulated Signal');
xlabel('Time (s)');
ylabel('Amplitude');
print -dpng 'DSB_SC_plot_time_demodulated.png'

figure;
grid on;
plot(t, y_SSB, 'LineWidth', 2);
title('SSB Demodulated Signal');
xlabel('Time (s)');
ylabel('Amplitude');
print -dpng 'SSB_plot_time_demodulated.png'

#+END_SRC

#+RESULTS:

:TODO: Theoretically

*** Part c


#+BEGIN_SRC octave :exports none :results output :session test
if exist('OCTAVE_VERSION', 'builtin')
  pkg load symbolic
end

fc = 1000;
Fs = 1000*fc;


%% Values
A1 = 5;
A2 = 20;
A3 = 10;
f1 = 50;
f2 = 100;
f3 = 150;
phi1 = pi/2;
phi2 = pi;
phi3 = pi/3;
w = 2*pi;

syms time

m = A1*cos(w*f1*time + phi1) + A2*cos(w*f2*time + phi2) + A3*cos(w*f3*time + phi3);
c = cos(2*pi * fc * time);
u = (1 + m).*c;
sympref display flat;
u
m

#+END_SRC

#+RESULTS:
#+begin_example
warning: passing floating-point values to sym is dangerous, see "help sym"
warning: called from
    double_to_sym_heuristic at line 50 column 7
    sym at line 384 column 13
    mtimes at line 54 column 5

warning: passing floating-point values to sym is dangerous, see "help sym"
warning: called from
    double_to_sym_heuristic at line 50 column 7
    sym at line 384 column 13
    plus at line 53 column 5

warning: passing floating-point values to sym is dangerous, see "help sym"
warning: called from
    double_to_sym_heuristic at line 50 column 7
    sym at line 384 column 13
    mtimes at line 54 column 5

warning: passing floating-point values to sym is dangerous, see "help sym"
warning: called from
    double_to_sym_heuristic at line 50 column 7
    sym at line 384 column 13
    mtimes at line 54 column 5

warning: passing floating-point values to sym is dangerous, see "help sym"
warning: called from
    double_to_sym_heuristic at line 50 column 7
    sym at line 384 column 13
    plus at line 53 column 5
warning: passing floating-point values to sym is dangerous, see "help sym"
warning: called from
    double_to_sym_heuristic at line 50 column 7
    sym at line 384 column 13
    mtimes at line 54 column 5
u = (sym) (-5*sin(26*sqrt(146)*time) - 20*cos(52*sqrt(146)*time) + 10*cos(78*sqrt(146)*time + pi/3) + 1)*cos(7*sqrt(805682)*time)
m = (sym) -5*sin(26*sqrt(146)*time) - 20*cos(52*sqrt(146)*time) + 10*cos(78*sqrt(146)*time + pi/3)
#+end_example


#+BEGIN_SRC octave :exports none :results output :session AM_Demodulation
clear all;
close all;

if exist('OCTAVE_VERSION', 'builtin')
  %% needed for findpeaks
  pkg load signal
end

fc = 1000;
Fs = 1000*fc;
t = 0:1/(Fs):0.1;

%% Values
A1 = 5;
A2 = 20;
A3 = 10;
f1 = 50;
f2 = 100;
f3 = 150;
phi1 = pi/2;
phi2 = pi;
phi3 = pi/3;
w = 2*pi;

m = A1*cos(w*f1*t + phi1) + A2*cos(w*f2*t + phi2) + A3*cos(w*f3*t + phi3);
c = cos(2*pi * fc * t);
u = (1 + m).*c;

figure;
grid on;
plot(t, u, 'LineWidth', 2, t, m, 'LineWidth', 2);
title('DSB Modulated Signal');
xlabel('Time (s)');
ylabel('Amplitude');

[pks, idx] = findpeaks(u, "DoubleSided");
E_max = max(abs(pks));
E_min = min(abs(pks));
a = (E_max - E_min)/(E_max + E_min);
printf("the modulation index is %f \n", a)

#+END_SRC

#+RESULTS:
: the modulation index is 0.991802



**** Envelope Detector
We want $f_m < \frac{1}{RC} < f_c$, this will remove the carrier frequency, but no the message frequencies.

#+BEGIN_SRC octave :exports none :results output :session AM_Env
data = dlmread('/home/baley/UTAS/org-roam/org-files/ENG308Assignment1Env.data', '\t');
t = data(:, 1);
u = data(:, 2);
m_demod = data(:, 3);
m_true = data(:, 4);

figure;
plot(t, u, 'LineWidth', 2, t, m_demod, 'LineWidth', 2, t, m_true, 'LineWidth', 2);
xlabel('Time (s)');
ylabel('Voltage (V)');
title('Conventional AM Envelope Detector Demodulation');
grid on;
#+END_SRC

#+RESULTS:




