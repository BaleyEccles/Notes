:PROPERTIES:
:ID:       d536e12c-b200-401a-a67c-1bf94978c6f6
:END:
#+title: ENG308 - Communication Systems 1 - Assignment 2 - Question 3, 4 & 5
#+date: [2025-05-22 Thu 13:32]
#+AUTHOR: Baley Eccles - 652137
#+STARTUP: latexpreview

* Question 3

** a
Bandwidth of the RCF filter is given by:
\[\frac{\alpha + 1}{T_s}\]

** b
#+BEGIN_SRC octave :exports none :results output :session Q3
clc
clear
close all

if exist('OCTAVE_VERSION', 'builtin')
  set(0, "DefaultLineLineWidth", 2);
  set(0, "DefaultAxesFontSize", 25);
  pkg load signal
  pkg load communications
end
size = 1000;
sps = 8;
span = 4;
L = span*sps;
n = -L:L;
Ts = 1;
Fs = sps/Ts;
tau = n / Fs; 
fc = 1/Ts;

rand_bits = round(rand(1, size));
symbols = 2 * rand_bits - 1;

x_impulse = zeros(1, size*sps);
x_impulse(1:sps:end) = symbols;
#+END_SRC

#+RESULTS:

** c
#+BEGIN_SRC octave :exports none :results output :session Q3
close all;
%% i - Ideal pulse
g_sq = ones(1, sps);
x1 = conv(x_impulse, g_sq, 'same');
c1 = awgn(x1, 10, 'measured');
r1 = conv(c1, fliplr(g_sq), 'same');
eyediagram(r1,2*sps)
title('Eye diagram – Ideal Pulse');

Nfft = 2^nextpow2(length(x1));
Xf = fftshift(fft(x1, Nfft))/length(x1);
faxis = (-Nfft/2:Nfft/2-1)*(Fs/Nfft);

figure
plot(faxis, 20*log10(abs(Xf))+eps); grid on
xlabel("Frequency (Hz)"); ylabel("dB");
title("Bandwidth - Ideal Pulse");


%% ii - Butterworth
h_lpf = exp(-abs(tau)*2*pi*fc);
g_sq_lp = conv(h_lpf, g_sq, 'same');
g_sq_lp = g_sq_lp / sum(g_sq_lp);

x2 = conv(x_impulse, g_sq_lp, 'same');
c2 = awgn(x2, 10, 'measured');
r2 = conv(c2, fliplr(g_sq_lp), 'same');
eyediagram(r2,2*sps)
title('Eye diagram – Butterworth');

Nfft = 2^nextpow2(length(x2));
Xf = fftshift(fft(x2, Nfft))/length(x2);
faxis = (-Nfft/2:Nfft/2-1)*(Fs/Nfft);

figure
plot(faxis, 20*log10(abs(Xf))+eps); grid on
xlabel("Frequency (Hz)"); ylabel("dB");
title("Bandwidth - Butterworth");


%% iii - SRRC
alpha = 0.4;
g_srrc = rcosfir(alpha, span, sps, 1, 'sqrt');
x3 = conv(x_impulse, g_srrc, 'same');
c3 = awgn(x3, 10, 'measured');
r3 = conv(c3, fliplr(g_srrc), 'same');
eyediagram(r3,2*sps)
title('Eye diagram – SRRC');

Nfft = 2^nextpow2(length(x3));
Xf = fftshift(fft(x3, Nfft))/length(x3);
faxis = (-Nfft/2:Nfft/2-1)*(Fs/Nfft);

figure
plot(faxis, 20*log10(abs(Xf))+eps); grid on
xlabel("Frequency (Hz)"); ylabel("dB");
title("Bandwidth - SRRC");

%% iv - RCF
g_rcf = rcosfir(alpha, span, sps, 1, 'normal');
x4 = conv(x_impulse, g_rcf, 'same');
c4 = awgn(x4, 10, 'measured');
r4 = conv(c4, fliplr(g_rcf), 'same');
eyediagram(r4,2*sps)
title('Eye diagram – RCF');

Nfft = 2^nextpow2(length(x4));
Xf = fftshift(fft(x4, Nfft))/length(x4);
faxis = (-Nfft/2:Nfft/2-1)*(Fs/Nfft);

figure
plot(faxis, 20*log10(abs(Xf))+eps); grid on
xlabel("Frequency (Hz)"); ylabel("dB");
title("Bandwidth - RCF");

#+END_SRC

#+RESULTS:

** d

** e

* Question 4
** a
The received signal is given by:
\[r(t) = s(t) + n(t)\]
And the output of the matched filter is:
\[h(t) &= s^H (-t)\]

\[y = \int_{-\infty}^{\infty}r(t)h(t)dt\]
\[y = \int_{-\infty}^{\infty}s(t)h(t)dt + \int_{-\infty}^{\infty}n(t)h(t)dt\]

The energy in the signal portion is $E_s = |y_s|^2$:
\[E_s = \lvert\int_{-\infty}^{\infty}s(t)h(t)dt\rvert^2\]
\[ \leq \int_{-\infty}^{\infty}|s(t)|^2dt \cdot \int_{-\infty}^{\infty}|h(t)|^2dt\]
let $\epsilon = \int_{-\infty}^{\infty}|s(t)|^2dt$ and $E_h$ be the other integral

The energy in the noise is $E_n = |y_n|^2$
\[E_s = |\int_{-\infty}^{\infty}n(t)h(t)dt|^2\]
Using the power spectral density given $\frac{N_0}{2}$
\[ = \frac{N_0}{2}\int_{-\infty}^{\infty}|h(t)|^2dt = \frac{N_0}{2}E_h\]

Now the $SNR$ can be found
\[SNR = \frac{E_s}{E_n} \leq \frac{\epsilon E_h}{\frac{N_0}{2} E_h} = \frac{2\epsilon}{N_0}\]
Hence the max $SNR$ is:
\[SNR_{\max} = \frac{2\epsilon}{N_0}\]
** b
Using the matched filter definition:
\[h(t) = \being{cases}
A & -T_s < t < 0 \\
0 & \textrm{else}
\end{cases}\]

And:
\[s(t) = \being{cases}
A & 0 < t < T_s \\
0 & \textrm{else}
\end{cases}\]

Using:
\[y = \int_{-\infty}^{\infty}s(t)h(t)dt + \int_{-\infty}^{\infty}n(t)h(t)dt\]
Which gives:
\[\int_{-\infty}^{\infty}s(t)h(t)dt = \int_0^{T_s}A\cdot Adt = A^2T_s\]
And:
\[\int_{-\infty}^{\infty}n(t)h(t)dt = \]

* Question 5



#+BEGIN_SRC octave :exports none :results output :session Q5
clc
clear
close all

if exist('OCTAVE_VERSION', 'builtin')
  set(0, "DefaultLineLineWidth", 2);
  set(0, "DefaultAxesFontSize", 25);
  pkg load signal
  pkg load communications
end



%% Constants
size = 10000;
sps = 8;
span = 4;
L = span*sps;
n = -L:L;
Ts = 1;
Fs = sps/Ts;
tau = n / Fs; 
fc = 1/Ts;

%% 16-PAM
PAM.sym = [ 0, 0, 0, 0, ...
            0, 0, 0, 1, ...
            0, 0, 1, 1, ...
            0, 0, 1, 0, ...
            0, 1, 1, 0, ...
            0, 1, 1, 1, ...
            0, 1, 0, 1, ...
            0, 1, 0, 0, ...
            1, 1, 0, 0, ...
            1, 1, 0, 1, ...
            1, 1, 1, 1, ...
            1, 1, 1, 0, ...
            1, 0, 1, 0, ...
            1, 0, 1, 1, ...
            1, 0, 0, 1, ...
            1, 0, 0, 0];

d = 2;
idx = -7:1:8;
PAM.loc = d.*idx - 1;

PAM_power = mean(PAM.loc.^2);

%% 16-PSK
PSK.sym = PAM.sym;
mag = sqrt(PAM_power);
theta = (0:16-1) * (2 * pi / 16);
PSK.loc = mag * exp(1j * theta);

%% Square 16-QAM
a = sqrt(PAM_power/10);
QAM.sym = PAM.sym;
QAM.loc = [-3*a + -3*a*i, ...
           -3*a + -1*a*i, ...
           -3*a +  1*a*i, ...
           -3*a +  3*a*i, ...
           -1*a +  3*a*i, ...
           -1*a +  1*a*i, ...
           -1*a + -1*a*i, ...
           -1*a + -3*a*i, ...
           +1*a + -3*a*i, ...
           +1*a + -1*a*i, ...
           +1*a +  1*a*i, ...
           +1*a +  3*a*i, ...
           +3*a +  3*a*i, ...
           +3*a +  1*a*i, ...
           +3*a + -1*a*i, ...
           +3*a + -3*a*i];


%% Generate values
rand_bits = round(rand(1, size));
%rand_bits = [0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0];
function val = gen_vals(sym, loc, bits)
  for i = 0:(length(bits)/4 - 1)
    b1 = bits(4*i + 1);
    b2 = bits(4*i + 2);
    b3 = bits(4*i + 3);
    b4 = bits(4*i + 4);
    for j = 0:(length(loc) - 1)
      if (b1 == sym(4*j + 1) && b2 == sym(4*j + 2) && b3 == sym(4*j + 3) && b4 == sym(4*j + 4))
        val(i + 1) = loc(j + 1);
      end
    end
  end
end


PAM.val = gen_vals(PAM.sym, PAM.loc, rand_bits);
PSK.val = gen_vals(PSK.sym, PSK.loc, rand_bits);
QAM.val = gen_vals(QAM.sym, QAM.loc, rand_bits);



snr_db = 1:1:15;

for idx = 0:(length(snr_db) - 1)
  snr = snr_db(idx + 1);
  
  snr_linear = 10.^(snr / 10);
  signal_power = mean(abs(PAM.val).^2);
  noise_power = signal_power / snr_linear;
  noise = sqrt(noise_power/2) * (randn(1, length(PAM.val)) + 1j * randn(1, length(PAM.val)));
  received_pam = PAM.val + noise;

  snr_linear = 10.^(snr / 10);
  signal_power = mean(abs(PSK.val).^2);
  noise_power = signal_power / snr_linear;
  noise = sqrt(noise_power/2) * (randn(1, length(PSK.val)) + 1j * randn(1, length(PSK.val)));
  received_psk = PSK.val + noise;
  
  snr_linear = 10.^(snr / 10);
  signal_power = mean(abs(QAM.val).^2);
  noise_power = signal_power / snr_linear;
  noise = sqrt(noise_power/2) * (randn(1, length(QAM.val)) + 1j * randn(1, length(QAM.val)));
  received_qam = QAM.val + noise;

  for i = 0:(length(received_pam) - 1)
    [~, bit_idx] = min(abs(received_pam(i + 1) - PAM.loc));
    abs(received_pam(i + 1) - PAM.loc);
    detected_pam(4*i + 1) = PAM.sym(4*(bit_idx - 1) + 1);
    detected_pam(4*i + 2) = PAM.sym(4*(bit_idx - 1) + 2);
    detected_pam(4*i + 3) = PAM.sym(4*(bit_idx - 1) + 3);
    detected_pam(4*i + 4) = PAM.sym(4*(bit_idx - 1) + 4);
  end
  ber_pam(idx + 1) = sum(rand_bits ~= detected_pam) / length(rand_bits);

  for i = 0:(length(received_psk) - 1)
    [~, bit_idx] = min(abs(received_psk(i + 1) - PSK.loc));
    abs(received_psk(i + 1) - PSK.loc);
    detected_psk(4*i + 1) = PSK.sym(4*(bit_idx - 1) + 1);
    detected_psk(4*i + 2) = PSK.sym(4*(bit_idx - 1) + 2);
    detected_psk(4*i + 3) = PSK.sym(4*(bit_idx - 1) + 3);
    detected_psk(4*i + 4) = PSK.sym(4*(bit_idx - 1) + 4);
  end
  ber_psk(idx + 1) = sum(rand_bits ~= detected_psk) / length(rand_bits);

  for i = 0:(length(received_qam) - 1)
    [~, bit_idx] = min(abs(received_qam(i + 1) - QAM.loc));
    abs(received_qam(i + 1) - QAM.loc);
    detected_qam(4*i + 1) = QAM.sym(4*(bit_idx - 1) + 1);
    detected_qam(4*i + 2) = QAM.sym(4*(bit_idx - 1) + 2);
    detected_qam(4*i + 3) = QAM.sym(4*(bit_idx - 1) + 3);
    detected_qam(4*i + 4) = QAM.sym(4*(bit_idx - 1) + 4);
  end
  ber_qam(idx + 1) = sum(rand_bits ~= detected_qam) / length(rand_bits);
  
end

figure;
semilogy(snr_db, ber_pam, 'o--', snr_db, ber_psk, 'o--', snr_db, ber_qam, 'o--');
xlabel('SNR (dB)');
ylabel('Bit Error Rate (BER)');
title('BER vs SNR in AWGN channel');
legend('PAM', 'PSK', 'QAM');
grid on;

#+END_SRC

#+RESULTS:

