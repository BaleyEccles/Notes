:PROPERTIES:
:ID:       d536e12c-b200-401a-a67c-1bf94978c6f6
:END:
#+title: ENG308 - Communication Systems 1 - Assignment 2 - Question 3, 4 & 5
#+date: [2025-05-22 Thu 13:32]
#+AUTHOR: Baley Eccles - 652137
#+STARTUP: latexpreview

* Question 3

** a
Bandwidth of the RCF filter is given by:
\[\frac{\alpha + 1}{T_s}\]

** b
#+BEGIN_SRC octave :exports none :results output :session Q3
clc
clear
close all

if exist('OCTAVE_VERSION', 'builtin')
  set(0, "DefaultLineLineWidth", 2);
  set(0, "DefaultAxesFontSize", 25);
  pkg load signal
  pkg load communications
end
size = 1000;
sps = 8;
span = 4;
L = span*sps;
n = -L:L;
Ts = 1;
Fs = sps/Ts;
tau = n / Fs; 
fc = 1/Ts;
snr = 5;

rand_bits = round(rand(1, size));
symbols = 2 * rand_bits - 1;

x_impulse = zeros(1, size*sps);
x_impulse(1:sps:end) = symbols;
#+END_SRC

#+RESULTS:

** c
#+BEGIN_SRC octave :exports none :results output :session Q3
close all;
%% i - Ideal pulse
g_sq = ones(1, sps);
x1 = conv(x_impulse, g_sq, 'same');
c1 = awgn(x1, snr, 'measured');
r1 = conv(c1, fliplr(g_sq), 'same');
eyediagram(r1,2*sps)
title('Eye diagram – Ideal Pulse');

Nfft = 2^nextpow2(length(x1));
Xf = fftshift(fft(x1, Nfft))/length(x1);
faxis = (-Nfft/2:Nfft/2-1)*(Fs/Nfft);

figure
plot(faxis, 20*log10(abs(Xf))+eps); grid on
xlabel("Frequency (Hz)"); ylabel("dB");
title("Bandwidth - Ideal Pulse");


%% ii - Butterworth
h_lpf = exp(-abs(tau)*2*pi*fc);
g_sq_lp = conv(h_lpf, g_sq, 'same');
g_sq_lp = g_sq_lp / sum(g_sq_lp);

x2 = conv(x_impulse, g_sq_lp, 'same');
c2 = awgn(x2, snr, 'measured');
r2 = conv(c2, fliplr(g_sq_lp), 'same');
eyediagram(r2,2*sps)
title('Eye diagram – Butterworth');

Nfft = 2^nextpow2(length(x2));
Xf = fftshift(fft(x2, Nfft))/length(x2);
faxis = (-Nfft/2:Nfft/2-1)*(Fs/Nfft);

figure
plot(faxis, 20*log10(abs(Xf))+eps); grid on
xlabel("Frequency (Hz)"); ylabel("dB");
title("Bandwidth - Butterworth");


%% iii - SRRC
alpha = 0.4;
g_srrc = rcosfir(alpha, span, sps, 1, 'sqrt');
x3 = conv(x_impulse, g_srrc, 'same');
c3 = awgn(x3, snr, 'measured');
r3 = conv(c3, fliplr(g_srrc), 'same');
eyediagram(r3,2*sps)
title('Eye diagram – SRRC');

Nfft = 2^nextpow2(length(x3));
Xf = fftshift(fft(x3, Nfft))/length(x3);
faxis = (-Nfft/2:Nfft/2-1)*(Fs/Nfft);

figure
plot(faxis, 20*log10(abs(Xf))+eps); grid on
xlabel("Frequency (Hz)"); ylabel("dB");
title("Bandwidth - SRRC");

%% iv - RCF
g_rcf = rcosfir(alpha, span, sps, 1, 'normal');
x4 = conv(x_impulse, g_rcf, 'same');
c4 = awgn(x4, snr, 'measured');
r4 = conv(c4, fliplr(g_rcf), 'same');
eyediagram(r4,2*sps)
title('Eye diagram – RCF');

Nfft = 2^nextpow2(length(x4));
Xf = fftshift(fft(x4, Nfft))/length(x4);
faxis = (-Nfft/2:Nfft/2-1)*(Fs/Nfft);

figure
plot(faxis, 20*log10(abs(Xf))+eps); grid on
xlabel("Frequency (Hz)"); ylabel("dB");
title("Bandwidth - RCF");

#+END_SRC

#+RESULTS:

** d

** e

* Question 4
** a
The received signal is given by:
\[r(t) = s(t) + n(t)\]
And the output of the matched filter is:
\[h(t) &= s^H (-t)\]

\[y = \int_{-\infty}^{\infty}r(t)h(t)dt\]
\[y = \int_{-\infty}^{\infty}s(t)h(t)dt + \int_{-\infty}^{\infty}n(t)h(t)dt\]

The energy in the signal portion is $E_s = |y_s|^2$:
\[E_s = \lvert\int_{-\infty}^{\infty}s(t)h(t)dt\rvert^2\]
\[ \leq \int_{-\infty}^{\infty}|s(t)|^2dt \cdot \int_{-\infty}^{\infty}|h(t)|^2dt\]
let $\epsilon = \int_{-\infty}^{\infty}|s(t)|^2dt$ and $E_h$ be the other integral

The energy in the noise is $E_n = |y_n|^2$
\[E_s = |\int_{-\infty}^{\infty}n(t)h(t)dt|^2\]
Using the power spectral density given $\frac{N_0}{2}$
\[ = \frac{N_0}{2}\int_{-\infty}^{\infty}|h(t)|^2dt = \frac{N_0}{2}E_h\]

Now the $SNR$ can be found
\[SNR = \frac{E_s}{E_n} \leq \frac{\epsilon E_h}{\frac{N_0}{2} E_h} = \frac{2\epsilon}{N_0}\]
Hence the max $SNR$ is:
\[SNR_{\max} = \frac{2\epsilon}{N_0}\]
** b
Using the matched filter definition:
\[h(t) = \being{cases}
A & -T_s < t < 0 \\
0 & \textrm{else}
\end{cases}\]

And:
\[s(t) = \being{cases}
A & 0 < t < T_s \\
0 & \textrm{else}
\end{cases}\]

Using:
\[y = \int_{-\infty}^{\infty}s(t)h(t)dt + \int_{-\infty}^{\infty}n(t)h(t)dt\]
Which gives:
\[\int_{-\infty}^{\infty}s(t)h(t)dt = \int_0^{T_s}A\cdot Adt = A^2T_s\]
And:
\[\int_{-\infty}^{\infty}n(t)h(t)dt = \]

* Question 5

#+BEGIN_SRC octave :exports none :results output :session Q5
clc
clear
close all

if exist('OCTAVE_VERSION', 'builtin')
  set(0, "DefaultLineLineWidth", 2);
  set(0, "DefaultAxesFontSize", 25);
  pkg load signal
  pkg load communications
  pkg load statistics
end

%% Constants
size = 2000;
sps = 8;
span = 4;
L = span*sps;
n = -L:L;
Ts = 1;
Fs = sps/Ts;
tau = n / Fs; 
fc = 1/Ts;

%% 16-PAM
PAM.sym = [ 0, 0, 0, 0, ...
            0, 0, 0, 1, ...
            0, 0, 1, 1, ...
            0, 0, 1, 0, ...
            0, 1, 1, 0, ...
            0, 1, 1, 1, ...
            0, 1, 0, 1, ...
            0, 1, 0, 0, ...
            1, 1, 0, 0, ...
            1, 1, 0, 1, ...
            1, 1, 1, 1, ...
            1, 1, 1, 0, ...
            1, 0, 1, 0, ...
            1, 0, 1, 1, ...
            1, 0, 0, 1, ...
            1, 0, 0, 0];

d = 2;
idx = -7:1:8;
PAM.loc = d.*idx - 1;

PAM_power = mean(PAM.loc.^2);

%% 16-PSK
PSK.sym = PAM.sym;
mag = sqrt(PAM_power);
theta = (0:16-1) * (2 * pi / 16);
PSK.loc = mag * exp(1j * theta);

%% Square 16-QAM
a = sqrt(PAM_power/10);
QAM.sym = PAM.sym;
QAM.loc = [-3*a + -3*a*i, ...
           -3*a + -1*a*i, ...
           -3*a +  1*a*i, ...
           -3*a +  3*a*i, ...
           -1*a +  3*a*i, ...
           -1*a +  1*a*i, ...
           -1*a + -1*a*i, ...
           -1*a + -3*a*i, ...
           +1*a + -3*a*i, ...
           +1*a + -1*a*i, ...
           +1*a +  1*a*i, ...
           +1*a +  3*a*i, ...
           +3*a +  3*a*i, ...
           +3*a +  1*a*i, ...
           +3*a + -1*a*i, ...
           +3*a + -3*a*i];


%% Generate values
rand_bits = round(rand(1, size));
%rand_bits = [0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0];
function val = gen_vals(sym, loc, bits)
  for i = 0:(length(bits)/4 - 1)
    b1 = bits(4*i + 1);
    b2 = bits(4*i + 2);
    b3 = bits(4*i + 3);
    b4 = bits(4*i + 4);
    for j = 0:(length(loc) - 1)
      if (b1 == sym(4*j + 1) && b2 == sym(4*j + 2) && b3 == sym(4*j + 3) && b4 == sym(4*j + 4))
        val(i + 1) = loc(j + 1);
      end
    end
  end
end


PAM.val = gen_vals(PAM.sym, PAM.loc, rand_bits);
PSK.val = gen_vals(PSK.sym, PSK.loc, rand_bits);
QAM.val = gen_vals(QAM.sym, QAM.loc, rand_bits);



function detected = detect(received, sym, loc)
  for i = 0:(length(received) - 1)
    [~, bit_idx] = min(abs(received(i + 1) - loc));
    abs(received(i + 1) - loc);
    detected(4*i + 1) = sym(4*(bit_idx - 1) + 1);
    detected(4*i + 2) = sym(4*(bit_idx - 1) + 2);
    detected(4*i + 3) = sym(4*(bit_idx - 1) + 3);
    detected(4*i + 4) = sym(4*(bit_idx - 1) + 4);
  end
end

snr_db = 1:1:30;

for idx = 0:(length(snr_db) - 1)
  snr = snr_db(idx + 1);
  snr_linear = 10.^(snr / 10);
  
  signal_power = mean(abs(PAM.val).^2);
  noise_power = signal_power / snr_linear;
  noise = sqrt(noise_power/2) * (randn(1, length(PAM.val)) + 1j * randn(1, length(PAM.val)));
  received_pam = PAM.val + noise;


  signal_power = mean(abs(PSK.val).^2);
  noise_power = signal_power / snr_linear;
  noise = sqrt(noise_power/2) * (randn(1, length(PSK.val)) + 1j * randn(1, length(PSK.val)));
  received_psk = PSK.val + noise;
  
  signal_power = mean(abs(QAM.val).^2);
  noise_power = signal_power / snr_linear;
  noise = sqrt(noise_power/2) * (randn(1, length(QAM.val)) + 1j * randn(1, length(QAM.val)));
  received_qam = QAM.val + noise;

  detected_pam = detect(received_pam, PAM.sym, PAM.loc);
  ber_pam(idx + 1) = sum(rand_bits ~= detected_pam) / length(rand_bits);

  detected_psk = detect(received_psk, PSK.sym, PSK.loc);
  ber_psk(idx + 1) = sum(rand_bits ~= detected_psk) / length(rand_bits);

  detected_qam = detect(received_qam, QAM.sym, QAM.loc);
  ber_qam(idx + 1) = sum(rand_bits ~= detected_qam) / length(rand_bits);
  
end

figure;
semilogy(snr_db, ber_pam, 'o--', snr_db, ber_psk, 'o--', snr_db, ber_qam, 'o--');
xlabel('SNR (dB)');
ylabel('Bit Error Rate (BER)');
title('BER vs SNR in AWGN channel');
legend('PAM', 'PSK', 'QAM');
grid on;

                                % Rayleigh Stuff

sigma = 10000;
frames = 50;
frameSize = size/frames/4
number_of_pilot_bits = 100;

%% lambda(j) = ray_vals(floor(j/block_size))


for idx = 0:(length(snr_db) - 1)
  snr = snr_db(idx + 1);
  snr_linear = 10.^(snr / 10);

  ber_ray_pam(idx + 1) = 0;
  ber_ray_psk(idx + 1) = 0;
  ber_ray_qam(idx + 1) = 0;
  for f = 0:(frames - 1)

    
    
    h = (randn+1j*randn)/sqrt(2);

    %% Pilot estimation
    %% h = (A^H A)^-1 A^H r

    %% A
    pilot_bits = ones(number_of_pilot_bits,1);
    
    signal_power = mean(abs(PAM.val).^2);
    noise_power = signal_power / snr_linear;
    noise = sqrt(noise_power/2) * (randn(1, length(pilot_bits)) + 1j * randn(1, length(pilot_bits))); % n
    received_pam = h.*pilot_bits + noise; % r
    
    pam_h_est = mean(pinv((pilot_bits')*(pilot_bits))*(pilot_bits')*(received_pam));
    
    
    signal_power = mean(abs(PSK.val).^2);
    noise_power = signal_power / snr_linear;
    noise = sqrt(noise_power/2) * (randn(1, length(pilot_bits)) + 1j * randn(1, length(pilot_bits))); % n
    received_psk = h.*pilot_bits + noise; % r
    psk_h_est = mean(pinv((pilot_bits')*(pilot_bits))*(pilot_bits')*(received_psk));

    signal_power = mean(abs(QAM.val).^2);
    noise_power = signal_power / snr_linear;
    noise = sqrt(noise_power/2) * (randn(1, length(pilot_bits)) + 1j * randn(1, length(pilot_bits))); % n
    received_qam = h.*pilot_bits + noise; % r
    qam_h_est = mean(pinv((pilot_bits')*(pilot_bits))*(pilot_bits')*(received_qam));

    
    %% Mod
    signal_power = mean(abs(PAM.val).^2);
    noise_power = signal_power / snr_linear;
    
    frame_pam = PAM.val((frameSize*f + 1):(frameSize*(f + 1)));
    noise = sqrt(noise_power/2) * (randn(1, length(frame_pam)) + 1j * randn(1, length(frame_pam)));

    received_pam = h.*frame_pam + noise;

    
    signal_power = mean(abs(PSK.val).^2);
    noise_power = signal_power / snr_linear;
    
    frame_psk = PSK.val((frameSize*f + 1):(frameSize*(f + 1)));
    noise = sqrt(noise_power/2) * (randn(1, length(frame_psk)) + 1j * randn(1, length(frame_psk)));
    received_psk = h.*frame_psk + noise;

    
    signal_power = mean(abs(QAM.val).^2);
    noise_power = signal_power / snr_linear;
    
    frame_qam = QAM.val((frameSize*f + 1):(frameSize*(f + 1)));
    noise = sqrt(noise_power/2) * (randn(1, length(frame_qam)) + 1j * randn(1, length(frame_qam)));
    received_qam = h.*frame_qam + noise;


    %% Demod
    frame_rand_bits = rand_bits((4*frameSize*f + 1):(4*frameSize*(f + 1)));

    detected_ray_pam = detect(received_pam./pam_h_est, PAM.sym, PAM.loc);
    ber_ray_pam(idx + 1) += sum(frame_rand_bits ~= detected_ray_pam) / length(frame_rand_bits);

    detected_ray_psk = detect(received_psk./psk_h_est, PSK.sym, PSK.loc);
    ber_ray_psk(idx + 1) += sum(frame_rand_bits ~= detected_ray_psk) / length(frame_rand_bits);

    detected_ray_qam = detect(received_qam./qam_h_est, QAM.sym, QAM.loc);
    ber_ray_qam(idx + 1) += sum(frame_rand_bits ~= detected_ray_qam) / length(frame_rand_bits);
  end
end

figure;
semilogy(snr_db, ber_ray_pam, 'o--', snr_db, ber_ray_psk, 'o--', snr_db, ber_ray_qam, 'o--');
xlabel("SNR (dB)");
ylabel("Bit Error Rate (BER)");
title(["BER vs SNR in AWGN channel and Flat Fading with ", num2str(number_of_pilot_bits), " pilot bits and ", num2str(frames), " frames"]);
legend('PAM', 'PSK', 'QAM');
grid on;

%% eta_b = R_b/B = SNR
%% B = R_b (1 + alpha)
%% eta_b = 1/(1 + alpha)
alpha = 0.4;
eta_b = 1/(1 + alpha);

%% eta_p = E_b/N_0 = SNR
eta_p = SNR;


#+END_SRC

#+RESULTS:
#+begin_example
warning: axis: omitting non-positive data in log plot
warning: called from
    __plt__>__plt2vv__ at line 502 column 10
    __plt__>__plt2__ at line 248 column 14
    __plt__ at line 115 column 16
    semilogy at line 65 column 10

warning: axis: omitting non-positive data in log plot
warning: called from
    __plt__>__plt2vv__ at line 502 column 10
    __plt__>__plt2__ at line 248 column 14
    __plt__ at line 115 column 16
    semilogy at line 65 column 10

warning: axis: omitting non-positive data in log plot
warning: called from
    __plt__>__plt2vv__ at line 502 column 10
    __plt__>__plt2__ at line 248 column 14
    __plt__ at line 115 column 16
    semilogy at line 65 column 10

warning: axis: omitting non-positive data in log plot
warning: called from
    __plt__>__plt2vv__ at line 502 column 10
    __plt__>__plt2__ at line 248 column 14
    __plt__ at line 115 column 16
    semilogy at line 65 column 10

warning: axis: omitting non-positive data in log plot
warning: called from
    __plt__>__plt2vv__ at line 502 column 10
    __plt__>__plt2__ at line 248 column 14
    __plt__ at line 115 column 16
    semilogy at line 65 column 10
warning: axis: omitting non-positive data in log plot
warning: called from
    legend at line 312 column 8
frameSize = 10
warning: axis: omitting non-positive data in log plot
warning: axis: omitting non-positive data in log plot
warning: axis: omitting non-positive data in log plot
warning: axis: omitting non-positive data in log plot
warning: called from
    legend>update_legend_position at line 1602 column 10
    legend>update_layout_cb at line 942 column 7
    legend>@<anonymous> at line 326 column 32

warning: axis: omitting non-positive data in log plot
warning: called from
    legend>update_legend_position at line 1602 column 10
    legend>update_layout_cb at line 942 column 7
    legend>@<anonymous> at line 326 column 32

warning: axis: omitting non-positive data in log plot
warning: called from
    legend>update_legend_position at line 1602 column 10
    legend>update_layout_cb at line 942 column 7
    legend>@<anonymous> at line 326 column 32

warning: axis: omitting non-positive data in log plot
warning: called from
    legend>update_legend_position at line 1602 column 10
    legend>update_layout_cb at line 942 column 7
    legend>@<anonymous> at line 326 column 32
error: parse error:

  syntax error
            ^
error: 'SNR' undefined near line 1, column 9
#+end_example
